{
  "hash": "4ed25e2c79eff4f8b2e2a77c867579d2",
  "result": {
    "markdown": "\n::: {.content-visible when-format=\"html\"}\n::: {.cell}\n\\newcommand{\\prob}{\\mathbf P}\n\\newcommand{\\lt}{<}\n\\newcommand{\\mt}{>}\n:::\n\n```{=html}\n<style>\ndiv.correction {\n  color: black;\n  background-color: #F0F0F0;\n  font-style: normal;\n  /*display: none;*/\n}\n\n.corR {\n  font-style: italic;\n  /*display: none;*/\n}\n</style>\n```\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\\solntrue\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n# Visualisation avec ggplot2 {#sec-ggplot2}\n\nIl est souvent nécessaire d'utiliser des techniques de visualisation au cours des différentes étapes d'un projet en science des données. Un des avantages de **R** est qu'il est relativement simple de mettre en œuvre tous les types de graphes généralement utilisés. Dans cette partie, nous présentons tout d'abord les fonctions classiques qui permettent de tracer des figures. Nous proposons ensuite une introduction aux graphes **ggplot** qui sont de plus en plus utilisés pour faire de la visualisation.\n\n## Fonctions graphiques conventionnelles\n\nPour commencer il est intéressant d'examiner quelques exemples de représentations graphiques construits avec **R**. On peut les obtenir à l'aide de la fonction **demo**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo(graphics)\n```\n:::\n\n\n\n### La fonction **plot**\n\nC'est une **fonction générique** que l'on peut utiliser pour représenter différents types de données. L'utilisation standard consiste à visualiser une variable *y* en fonction d'une variable *x*. On peut par exemple obtenir le graphe de la fonction $x\\mapsto \\sin(2\\pi x)$ sur $[0,1]$, à l'aide de\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- seq(-2*pi,2*pi,by=0.05)\ny <- sin(x)\nplot(x,y) #points (par défaut)\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-3-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nplot(x,y,type=\"l\") #représentation sous forme de ligne\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-3-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nNous proposons des exemples de représentations de variables quantitatives et qualitatives à travers du jeu de données **ozone.txt** que l'on importe avec\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozone <- read.table(\"data/ozone.txt\")\nsummary(ozone)\n##      maxO3              T9             T12             T15       \n##  Min.   : 42.00   Min.   :11.30   Min.   :14.00   Min.   :14.90  \n##  1st Qu.: 70.75   1st Qu.:16.20   1st Qu.:18.60   1st Qu.:19.27  \n##  Median : 81.50   Median :17.80   Median :20.55   Median :22.05  \n##  Mean   : 90.30   Mean   :18.36   Mean   :21.53   Mean   :22.63  \n##  3rd Qu.:106.00   3rd Qu.:19.93   3rd Qu.:23.55   3rd Qu.:25.40  \n##  Max.   :166.00   Max.   :27.00   Max.   :33.50   Max.   :35.50  \n##       Ne9             Ne12            Ne15           Vx9         \n##  Min.   :0.000   Min.   :0.000   Min.   :0.00   Min.   :-7.8785  \n##  1st Qu.:3.000   1st Qu.:4.000   1st Qu.:3.00   1st Qu.:-3.2765  \n##  Median :6.000   Median :5.000   Median :5.00   Median :-0.8660  \n##  Mean   :4.929   Mean   :5.018   Mean   :4.83   Mean   :-1.2143  \n##  3rd Qu.:7.000   3rd Qu.:7.000   3rd Qu.:7.00   3rd Qu.: 0.6946  \n##  Max.   :8.000   Max.   :8.000   Max.   :8.00   Max.   : 5.1962  \n##       Vx12             Vx15            maxO3v           vent          \n##  Min.   :-7.878   Min.   :-9.000   Min.   : 42.00   Length:112        \n##  1st Qu.:-3.565   1st Qu.:-3.939   1st Qu.: 71.00   Class :character  \n##  Median :-1.879   Median :-1.550   Median : 82.50   Mode  :character  \n##  Mean   :-1.611   Mean   :-1.691   Mean   : 90.57                     \n##  3rd Qu.: 0.000   3rd Qu.: 0.000   3rd Qu.:106.00                     \n##  Max.   : 6.578   Max.   : 5.000   Max.   :166.00                     \n##     pluie          \n##  Length:112        \n##  Class :character  \n##  Mode  :character  \n##                    \n##                    \n## \n```\n:::\n\n\n\nOn visualise tout d'abord 2 variables quantitatives à l'aide d'un nuage de points : la concentration en ozone maximale **maxO3** en fonction de la température à 12h **T12**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(ozone[,\"T12\"],ozone[,\"maxO3\"])\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-5-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nComme les deux variables appartiennent au même jeu de données, on peut obtenir la même représentation à l'aide d'une sytaxe plus claire qui ajoute automatiquement les noms des variables sur les axes :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(maxO3~T12,data=ozone)\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-6-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nUne autre façon de faire (moins naturelle) :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(ozone[,\"T12\"],ozone[,\"maxO3\"],xlab=\"T12\",ylab=\"maxO3\")\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-7-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nIl existe des fonctions spécifiques pour chaque type de graphes, par exemple **histogram**, **barplot** et **boxplot** :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(ozone$maxO3,main=\"Histogram\")\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-8-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nbarplot(table(ozone$vent)/nrow(ozone),col=\"blue\")\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-8-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nboxplot(maxO3~vent,data=ozone)\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-8-3.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n### Graphes interactifs avec rAmCharts\n\nOn peut utiliser ce package pour obtenir des graphes dynamiques. L'utilisation est relativement simple, il suffit d'ajouter le préfixe **am** devant le nom de la fonction :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rAmCharts)\namHist(ozone$maxO3)\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-9-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\namPlot(ozone,col=c(\"T9\",\"T12\"))\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-9-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\namBoxplot(maxO3~vent,data=ozone)\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-9-3.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n### Quelques exercices\n\n::: {#exr-exo1 name=\"Premier graphe\"}\nOn s'intéresse à quelques graphes simples.\n\n1.  Tracer la fonction **sinus** entre $0$ et $2\\pi$.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    x <- seq(0,2*pi,length=1000)\n    plot(x,sin(x),type=\"l\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-10-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n2.  A l'aide de la fonction **title** ajouter le titre **Représentation de la fonction sinus**.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    title(\"Représentation de la fonction sinus\")\n    ```\n    :::\n\n    ::: {.cell}\n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-12-1.pdf)\n    :::\n    :::\n\n\n:::\n\n::: {#exr-exo2 name=\"Tracé de densités\"}\nOn souhaite ici visualiser et comparer des densités de probabilité.\n\n1.  Tracer la densité de la loi normale centrée réduite entre $-4$ et 4 (utiliser **dnorm**).\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    x <- seq(-4,4,by=0.01)\n    plot(x,dnorm(x),type=\"l\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-13-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n2.  Ajouter une ligne verticale (en tirets) qui passe par $x=0$ (utiliser **abline** avec l'option **lty=2**).\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    abline(v=0,lty=2)\n    ```\n    :::\n\n    ::: {.cell}\n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-15-1.pdf)\n    :::\n    :::\n\n\n\n3.  Sur le même graphe, ajouter les densités de loi la de Student à 5 et 30 degrés de liberté (utiliser **dt**). On utilisera la fonction **lines** et des couleurs différentes pour chaque densité.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    lines(x,dt(x,5),col=2)\n    lines(x,dt(x,30),col=3)\n    ```\n    :::\n\n    ::: {.cell}\n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-17-1.pdf)\n    :::\n    :::\n\n\n\n4.  Ajouter une légende qui permette d'identifier chaque densité (fonction **legend**).\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    legend(\"topleft\",legend=c(\"Normal\",\"Student(5)\",\"Student(30)\"),\n       col=1:3,lty=1)\n    ```\n    :::\n\n    ::: {.cell}\n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-19-1.pdf)\n    :::\n    :::\n\n\n:::\n\n::: {#exr-exo3 name=\"Tâches solaires\"}\nOn souhaite ici visualiser une série temporelle.\n\n1.  Importer la série **taches_solaires.csv** qui donne, date par date, un nombre de taches solaires observées.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    taches <- read.table(\"data/taches_solaires.csv\",sep=\";\",header=TRUE,dec=\",\")\n    ```\n    :::\n\n\n\n2.  A l'aide de la fonction **cut_interval** du package `ggplot2`, créer un facteur qui sépare l'intervalle d'années d'observation en 8 intervalles de tailles à peu près égales. On appellera **periode** ce facteur.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    periode <- ggplot2::cut_interval(taches$annee,n=8)\n    ```\n    :::\n\n\n\n3.  Utiliser les levels suivants pour le facteur **periode**.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    couleurs <- c(\"yellow\", \"magenta\", \"orange\", \"cyan\",\n              \"grey\", \"red\", \"green\", \"blue\")\n    ```\n    :::\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    levels(periode) <- couleurs\n    ```\n    :::\n\n\n\n4.  Expliquer la sortie de la fonction\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    coordx <- seq(along=taches[,1])\n    ```\n    :::\n\n\n\n    ::: {.corR data-latex=\"\"}\n    On crée une séquence avec un pas de 1 de longueur égale à la dimension de `taches[,1]`.\n    :::\n\n5.  Visualiser la série du nombre de taches en utilisant une couleur différente pour chaque période.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    plot(coordx,taches[,1],xlab=\"Temps\",ylab=\"Nombre de taches\",\n     col=periode,type=\"p\",pch=\"+\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-25-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n:::\n\n::: {#exr-exo4 name=\"Layout\"}\nOn reprend le jeu de données sur l'ozone. A l'aide de la fonction **layout** séparer la fenêtre graphique en deux lignes avec\n\n-   un graphe sur la première ligne (nuage de points **maxO3 vs T12**)\n\n-   2 graphes sur la deuxième ligne (histogramme de **T12** et boxplot de **maxO3**).\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    layout(matrix(c(1,1,2,3), 2, 2, byrow = TRUE))\n    plot(maxO3~T12,data=ozone)\n    hist(ozone$T12)\n    boxplot(ozone$maxO3)\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-26-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n:::\n\n## La grammaire **ggplot2**\n\nCe package propose de définir des graphes sur **R** en utilisant une **grammaire des graphiques** (tout comme **dplyr** pour manipuler les données). On peut trouver de la documentation sur ce package aux url <https://ggplot2.tidyverse.org> et <https://ggplot2-book.org/index.html>\n\n### Premiers graphes `ggplot2`\n\nNous considérons un sous échantillon du jeu de données `diamonds` du package **ggplot2** (que l'on peut également charger avec le package **tidyverse**).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nset.seed(1234)\ndiamonds2 <- diamonds[sample(nrow(diamonds),5000),] \nsummary(diamonds2)\n##      carat               cut       color       clarity         depth      \n##  Min.   :0.2000   Fair     : 158   D: 640   SI1    :1189   Min.   :43.00  \n##  1st Qu.:0.4000   Good     : 455   E: 916   VS2    :1157   1st Qu.:61.10  \n##  Median :0.7000   Very Good:1094   F: 900   SI2    : 876   Median :61.80  \n##  Mean   :0.7969   Premium  :1280   G:1018   VS1    : 738   Mean   :61.76  \n##  3rd Qu.:1.0400   Ideal    :2013   H: 775   VVS2   : 470   3rd Qu.:62.50  \n##  Max.   :4.1300                    I: 481   VVS1   : 326   Max.   :71.60  \n##                                    J: 270   (Other): 244                  \n##      table           price             x                y        \n##  Min.   :49.00   Min.   :  365   Min.   : 0.000   Min.   :3.720  \n##  1st Qu.:56.00   1st Qu.:  945   1st Qu.: 4.720   1st Qu.:4.720  \n##  Median :57.00   Median : 2376   Median : 5.690   Median :5.700  \n##  Mean   :57.43   Mean   : 3917   Mean   : 5.728   Mean   :5.731  \n##  3rd Qu.:59.00   3rd Qu.: 5294   3rd Qu.: 6.530   3rd Qu.:6.520  \n##  Max.   :95.00   Max.   :18757   Max.   :10.000   Max.   :9.850  \n##                                                                  \n##        z        \n##  Min.   :0.000  \n##  1st Qu.:2.920  \n##  Median :3.520  \n##  Mean   :3.538  \n##  3rd Qu.:4.030  \n##  Max.   :6.430  \n## \nhelp(diamonds)\n```\n:::\n\n\n\nUn graphe **ggplot** est défini à partir de **couches** que l'on assemblera avec l'opérateur `+`. Il faut a minima spécifier :\n\n-   les données\n-   les variables que l'on souhaite représenter\n-   le type de représentation (nuage de points, boxplot...).\n\nIl existe un verbe pour définir chacune de ces couches :\n\n-   **ggplot** pour les données\n-   **aes** (aesthetics) pour les variables\n-   **geom\\_** pour le type de représentation.\n\nOn peut obtenir le nuage de points **carat vs price** avec la fonction **plot** :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(price~carat,data=diamonds2)\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-28-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nAvec **ggplot**, on va faire\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds2) #rien\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-29-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nggplot(diamonds2)+aes(x=carat,y=price) #rien\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-29-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nggplot(diamonds2)+aes(x=carat,y=price)+geom_point() #bon\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-29-3.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n::: {#exr-exoggplot1 name=\"Premiers graphes ggplot\"}\n\\\n\n1.  Tracer l'histogramme de la variable `carat` (utiliser `geom_histogram`).\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(diamonds2)+aes(x=carat)+geom_histogram()\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-30-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n2.  Même question en utilisant 10 classes pour l'histogramme (**help(geom_histogram)**).\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(diamonds2)+aes(x=carat)+geom_histogram(bins=10)\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-31-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n3.  Tracer le diagramme en barres de la variable `cut` (utiliser **geom_bar**).\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(diamonds2)+aes(x=cut)+geom_bar()\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-32-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n:::\n\nLa syntaxe **ggplot** est définie à partir d'éléments indépendants qui définissent la grammaire de **ggplot**. Les principaux verbes sont :\n\n-   **Data** (`ggplot`) : les données au format **dataframe** ou **tibble**\n-   **Aesthetics** (`aes`) : pour sépecifier les variables à représenter dans le graphe.\n-   **Geometrics** (`geom_...`) : le type de graphe (nuage de points, histogramme...).\n-   **Statistics** (`stat_...`) : utile pour spécifier des transformations des données nécessaires pour obtenir le graphe.\n-   **Scales** (`scale_...`) : pour controler les paramètres permettant d'affiner le graphe (changement de couleurs, paramètres des axes...).\n\nTous ces éléments sont reliés avec le symbole **+**.\n\n### Data et aesthetics\n\nCes deux verbes sont à utiliser pour tous les graphes **ggplot**. Le verbe `ggplot` sert à spécifier le jeu de données que l'on souhaite utiliser. Si le code est bien fait, nous n'aurons plus à utiliser le nom du jeu de données par la suite pour construire le graphe. Le verbe `aes` est quant à lui utile pour spécifier les variables que l'on souhaite visualiser. Par exemple, pour le nuage de points **price vs carat** la syntaxe débute avec\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds2)+aes(x=carat,y=price)\n```\n:::\n\n\n\nLes variables peuvent également être utilisées pour colorier des points ou des barres, définir des tailles... Dans ce cas on pourra renseigner les options **color**, **size**, **fill** dans la fonction `aes`. Par exemple\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds2)+aes(x=carat,y=price,color=cut)\n```\n:::\n\n\n\n### Geometrics\n\nCe verbe décrira le type de représentation souhaité. Pour un nuage de points, on utilisera par exemple **geom_point** :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds2)+aes(x=carat,y=price,color=cut)+geom_point()\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-35-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nOn observe que **ggplot** ajoute la légende automatiquement. Voici les principaux exemples de **geometrics** :\n\n| Geom             | Description                        | Aesthetics                             |\n|-------------------|---------------------------|--------------------------|\n| geom_point()     | nuage de points                    | x, y, shape, fill                      |\n| geom_line()      | Ligne (ordonnée selon x)           | x, y, linetype                         |\n| geom_abline()    | Ligne                              | slope, intercept                       |\n| geom_path()      | Ligne (ordonnée par l'index)       | x, y, linetype                         |\n| geom_text()      | Texte                              | x, y, label, hjust, vjust              |\n| geom_rect()      | Rectangle                          | xmin, xmax, ymin, ymax, fill, linetype |\n| geom_polygon()   | Polygone                           | x, y, fill, linetype                   |\n| geom_segment()   | Segment                            | x, y, xend, yend, fill, linetype       |\n| geom_bar()       | Diagramme en barres                | x, fill, linetype, weight              |\n| geom_histogram() | Histogramme                        | x, fill, linetype, weight              |\n| geom_boxplot()   | Boxplot                            | x, fill, weight                        |\n| geom_density()   | Densité                            | x, y, fill, linetype                   |\n| geom_contour()   | Lignes de contour                  | x, y, fill, linetype                   |\n| geom_smooth()    | Lisseur (linéaire ou non linéaire) | x, y, fill, linetype                   |\n| Tous             |                                    | color, size, group                     |\n\n: Principaux geometrics {#tbl-geom}\n\n::: {#exr-exoggplot2 name=\"Diagrammes en barres\"}\nOn étudie différentes façons de changer la couleur dans un diagramme en barres.\n\n1.  Tracer le diagramme en barres de la variable **cut** avec des barres bleues.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(diamonds2)+aes(x=cut)+geom_bar(fill=\"blue\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-36-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n2.  Tracer le diagramme en barres de la variable **cut** avec une couleur pour chaque modalité de **cut** ainsi qu'une légende qui permet de repérer la couleur.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(diamonds2)+aes(x=cut,fill=cut)+geom_bar()\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-37-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n3.  Tracer le diagramme en barres de la variable **cut** avec une couleur pour chaque modalité que vous choisirez (et sans légende).\n\n    ::: {.corR data-latex=\"\"}\n    On peut ajouter l'option `show.legend = FALSE` dans **geom_bar** :\n    :::\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(diamonds2)+aes(x=cut,fill=cut)+geom_bar(show.legend = FALSE)\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-38-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n    ::: {.corR data-latex=\"\"}\n    ou spécifier directement les couleurs (toujours dans **geom_bar**) :\n    :::\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(diamonds2)+aes(x=cut)+geom_bar(fill=c(\"blue\",\"red\",\"green\",\"yellow\",\"black\"))\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-39-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n:::\n\n### Statistics\n\nCertains graphes nécessitent des calculs d'indicateurs statistiques pour être tracé. C'est par exemple le cas pour le diagramme en barres et l'histogramme où il faut calculer des hauteurs de rectangles ou barres. On peut spécifier les transformations simples facilement, par exemple\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nD <- data.frame(X=seq(-2*pi,2*pi,by=0.01))\nggplot(D)+aes(x=X,y=sin(X))+geom_line()\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-40-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nLa transformation est spécifiée dans la fonction `aes`. Pour des transformations plus complexes, nous devons utiliser le verbe **statistics**. Une fonction **stat\\_** permet de définir des nouvelles variables à partir du jeu de données initial, il est ensuite possible de représenter ces nouvelles variables. Par exemple, la fonction **stat_bin**, qui est utilisée par défaut pour construire des histogrammes, calcule les variables suivantes :\n\n-   `count`, le nombre d'observations dans chaque classes.\n-   `density`, la valeur de la densité des observations dans chaque classe (fréqunce divisée par largeur de la classe).\n-   `x`, le centre de la classe.\n\nPar défaut **geom_histogram** fait appel à cette fonction `stat_bin` grâce à l'option `stat=\"bin\"`. On visualise ainsi sur l'axe $y$ le nombre d'observations dans chaque classe (la variable **count**).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds2)+aes(x=price)+geom_histogram(bins=40)\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-41-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nSi on souhaite une autre variable issue de `stat_bin`, comme par exemple la densité, il faudra utiliser\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds2)+aes(x=price,y=..density..)+geom_histogram(bins=40)\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-42-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nLes fonctions **stat\\_** peuvent être utilisées à la place des **geom\\_** pour certaines représentations. Chaque fonction **stat\\_** possède par défaut un **geom\\_** et réciproquement. On peut par exemple obtenir le même graphe que précédemment avec\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds2)+aes(x=price,y=..density..)+stat_bin()\n```\n:::\n\n\n\nVoici quelques exemple de fonctions **stat\\_**\n\n| Stat            | Description           | Paramètres       |\n|-----------------|-----------------------|------------------|\n| stat_identity() | aucune transformation |                  |\n| stat_bin()      | Count                 | binwidth, origin |\n| stat_density()  | Density               | adjust, kernel   |\n| stat_smooth()   | Smoother              | method, se       |\n| stat_boxplot()  | Boxplot               | coef             |\n\n: Exemple de statistics {#tbl-ggplot-stat}\n\n*stat* et *geom* ne sont pas toujours simples à combiner. Nous recommandons d'utiliser **geom** lorsqu'on débute avec **ggplot**, les `statistics`par défaut ne doivent en effet être changés que rarement.\n\n::: {#exr-exo-stat1 name=\"Diagramme en barres \\\"très simple\\\"...\"}\nOn considère une variable qualitative $X$ dont la loi est donnée par $$P(X=\\text{red})=0.3,\\ P(X=\\text{blue})=0.2,\\ P(X=\\text{green})=0.4,\\ P(X=\\text{black})=0.1$$ Représenter cette distribution de probabilité avec un diagramme en barres.\n\n::: {.corR data-latex=\"\"}\nLa difficulté ici vient du fait que les hauteurs de barre sont données : il ne faut pas les calculer à partir des données. On n'a donc pas à utiliser **stat_count** de **geom_bar**, if faut faire appel à **stat_identity**:\n:::\n\n\n\n::: {.cell teacher='true'}\n\n```{.r .cell-code}\ndf <- data.frame(var=c(\"red\",\"blue\",\"green\",\"black\"),prob=c(0.3,0.2,0.4,0.1))\nggplot(df)+aes(x=var,y=prob)+geom_bar(stat=\"identity\")+xlab(\"\")\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-44-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n::: {.corR data-latex=\"\"}\nOn peut aussi utiliser l'**aes** `weight` :\n:::\n\n\n\n::: {.cell teacher='true'}\n\n```{.r .cell-code}\nggplot(df)+aes(x=var,weight=prob)+geom_bar()+ylab(\"prob\")\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-45-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::\n\n::: {#exr-exo-stat2 name=\"Lissage\"}\nOn étudie différentes façons de visualiser un lissage.\n\n1.  Représenter le lissage non linéaire de la variable `price` contre la variable `carat` à l'aide de `geom_smooth` puis de `stat_smooth`.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(diamonds2)+aes(x=carat,y=price)+geom_smooth(method=\"loess\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-46-1.pdf){fig-pos='H'}\n    :::\n    \n    ```{.r .cell-code}\n    ggplot(diamonds2)+aes(x=carat,y=price)+stat_smooth(method=\"loess\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-46-2.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n2.  Même question mais avec une ligne en pointillés à la place d'un trait plein.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(diamonds2)+aes(x=carat,y=price)+geom_smooth(method=\"loess\",linetype=\"dotted\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-47-1.pdf){fig-pos='H'}\n    :::\n    \n    ```{.r .cell-code}\n    ggplot(diamonds2)+aes(x=carat,y=price)+stat_smooth(method=\"loess\",geom=\"point\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-47-2.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n:::\n\n### Scales\n\nLes échelles (**scales**) controlent tout un tas d'options telles que des changements de couleurs, d'échelles ou de limites d'axes, de symboles, etc... L'utilisation n'est pas simple et nécessite de la pratique. On utilise généralement ce verbe à la dernière étape de construction du graphe. La syntaxe est définie comme suit :\n\n-   début : `scale_`.\n-   ajout de l'aesthetics que l'on souhaite modifier (`color_`, `fill_`, `x_`).\n-   fin : nom de l'échelle (`manual`, `identity`...)\n\nPar exemple,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds2)+aes(x=carat,y=price,color=cut)+geom_point()+\n  scale_color_manual(values=c(\"Fair\"=\"black\",\"Good\"=\"yellow\",\n                              \"Very Good\"=\"blue\",\"Premium\"=\"red\",\"Ideal\"=\"green\"))\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-48-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nVoici quelques exemples des principales échelles :\n\n| aes                     | Discret  | Continu   |\n|-------------------------|----------|-----------|\n| Couleur (color et fill) | brewer   | gradient  |\n| \\-                      | grey     | gradient2 |\n| \\-                      | hue      | gradientn |\n| \\-                      | identity |           |\n| \\-                      | manual   |           |\n| Position (x et y)       | discrete | continous |\n| \\-                      |          | date      |\n| Forme                   | shape    |           |\n| \\-                      | identity |           |\n| \\-                      | manual   |           |\n| Taille                  | identity | size      |\n| \\-                      | manual   |           |\n\n: Exemples d'échelles {#tbl-scales}\n\nNous présentons quelques exemples d'utilisation des échelles :\n\n-   **Couleur dans un diagramme en barres**\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    p1 <- ggplot(diamonds2)+aes(x=cut)+geom_bar(aes(fill=cut))\n    p1\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-49-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n    On change la couleur en utilisant la palette **Purples** :\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    p1+scale_fill_brewer(palette=\"Purples\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-50-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n-   **Gradient de couleurs pour un nuage de points** :\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    p2 <- ggplot(diamonds2)+aes(x=carat,y=price)+geom_point(aes(color=depth))\n    p2\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-51-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n    On change le gradient de couleur\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    p2+scale_color_gradient(low=\"red\",high=\"yellow\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-52-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n-   **Modifications sur les axes**\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    p2+scale_x_continuous(breaks=seq(0.5,3,by=0.5))+\n      scale_y_continuous(name=\"prix\")+\n      scale_color_gradient(\"Profondeur\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-53-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n### Group et facets\n\n**ggplot** permet de faire des représentations pour des groupes d'individus. On procède généralement de deux façons différentes :\n\n-   visualisation de sous groupes sur le même graphe, on utilise l'option `group` dans le verbe **aes** ;\n-   visualisation de sous groupes sur des graphes différents, on utilise le verbe **facet_wrap** ou **facet_grid**.\n\nReprésentons ici (sur le même graphe) le lisseur **price vs carat** pour chaque modalité de *cut*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds2)+aes(x=carat,y=price,group=cut)+\n  geom_smooth(method=\"loess\")\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-54-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nPour obtenir cette représentation sur plusieurs fenêtres, on utilise\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds2)+aes(x=carat,y=price)+\n  geom_smooth(method=\"loess\")+facet_wrap(~cut)\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-55-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nggplot(diamonds2)+aes(x=carat,y=price)+\n  geom_smooth(method=\"loess\")+facet_wrap(~cut,nrow=1)\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-55-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n**facet_grid** et **facet_wrap** font des choses proches mais divisent la fenêtre d'une façon différente :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds2)+aes(x=carat,y=price)+geom_point()+\n  geom_smooth(method=\"lm\")+facet_grid(color~cut)\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-56-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nggplot(diamonds2)+aes(x=carat,y=price)+geom_point()+\n  geom_smooth(method=\"lm\")+facet_wrap(color~cut)\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-56-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Compléments\n\nLa syntaxe **ggplot** est définie selon le schéma :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+aes()+geom_()+scale_()\n```\n:::\n\n\n\nElle est très flexible, on peut par exemple spécifier les variables de `aes` dans les verbes `ggplot` ou `geom_` :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(diamonds2)+aes(x=carat,y=price)+geom_point()\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-58-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nggplot(diamonds2,aes(x=carat,y=price))+geom_point()\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-58-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nggplot(diamonds2)+geom_point(aes(x=carat,y=price))\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-58-3.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nCeci peut se révéler très utile lorsqu'on utilise des **aes** différents dans les **geom\\_**.\n\nOn peut aussi construire un graphe à l'aide de différents jeux de données :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX <- seq(-2*pi,2*pi,by=0.001)\nY1 <- cos(X)\nY2 <- sin(X)\ndonnees1 <- data.frame(X,Y1)\ndonnees2 <- data.frame(X,Y2)\nggplot(donnees1)+geom_line(aes(x=X,y=Y1))+\n  geom_line(data=donnees2,aes(x=X,y=Y2),color=\"red\")\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-59-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nIl existe d'autres fonctions **ggplot** :\n\n-   **ggtitle** pour ajouter un titre.\n-   **ggsave** pour sauver un graphe.\n-   **theme\\_** pour changer le theme du graphe.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- ggplot(diamonds2)+aes(x=carat,y=price,color=cut)+geom_point()\np+theme_bw()\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-60-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\np+theme_classic()\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-60-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\np+theme_grey()\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-60-3.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\np+theme_bw()\n```\n\n::: {.cell-output-display}\n![](04-ggplot_files/figure-pdf/unnamed-chunk-60-4.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nD'autres thèmes sont disponibles dans le package **ggtheme**. On pourra également parler de la fonction `set_theme` qui permet de modifier le thème par défaut pour un document **quarto**.\n\n## Quelques exercices supplémentaires\n\n::: {#exr-exo-cos-sin name=\"Fonctions cosinus et sinus\"}\nL'objectif est de visualiser les fonctions **sinus** et **cosinus** de plusieurs façons.\n\n1.  Tracer les fonctions sinus et cosinus. On utilisera tout d'abord les deux jeux de données suivants (un pour le sinus, l'autre pour le cosinus) :\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    donnees1 <- tibble(X=seq(-2*pi,2*pi,by=0.001),\n                       cos=cos(X))\n    donnees2 <- tibble(X=seq(-2*pi,2*pi,by=0.001),\n                       sin=sin(X))\n    ```\n    :::\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(donnees1)+geom_line(aes(x=X,y=cos))+\n      geom_line(data=donnees2,aes(x=X,y=sin),color=\"red\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-62-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n2.  Faire la même chose avec le jeu de données suivent qui regroupe les informations du cosinus et du sinus (on pourra ajouter une légende) :\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    donnees <- tibble(X=seq(-2*pi,2*pi,by=0.001),\n                       cos=cos(X),sin=sin(X))\n    ```\n    :::\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(donnees)+aes(x=X,y=cos)+geom_line()+\n      geom_line(aes(y=sin),color=\"red\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-64-1.pdf){fig-pos='H'}\n    :::\n    \n    ```{.r .cell-code}\n    #ou pour la légende\n    ggplot(donnees)+aes(x=X,y=cos)+geom_line(aes(color=\"cos\"))+\n      geom_line(aes(y=sin,color=\"sin\"))+labs(color=\"Fonction\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-64-2.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n3.  Faire la même chose avec un jeu de données et un seul appel à `geom_line`. On pourra utiliser la fonction **pivot_longer** du **tidyverse**.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    df1 <- donnees |> \n      pivot_longer(cols=c(cos,sin),\n                   names_to = \"Fonction\",\n                   values_to = \"value\")\n    #ou\n    df1 <- donnees |> \n      pivot_longer(cols=-X,\n                   names_to = \"Fonction\",\n                   values_to = \"value\")\n    ggplot(df1)+aes(x=X,y=value,color=Fonction)+geom_line()\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-65-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n4.  Tracer les deux fonctions sur deux fenêtres graphiques (utiliser `facet_wrap`).\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(df1)+aes(x=X,y=value)+geom_line()+facet_wrap(~Fonction)\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-66-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n5.  Faire la même chose avec la fonction `grid.arrange` du package **gridExtra**.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    library(gridExtra)\n    p1 <- ggplot(donnees1)+aes(x=X,y=cos)+geom_line()\n    p2 <- ggplot(donnees2)+aes(x=X,y=sin)+geom_line()\n    grid.arrange(p1,p2,nrow=1)\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-67-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n:::\n\n::: {#exr-exo-mtcars name=\"Différents graphes\"}\nOn considère les données `mtcars`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(mtcars)\nsummary(mtcars)\n##       mpg             cyl             disp             hp       \n##  Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0  \n##  1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5  \n##  Median :19.20   Median :6.000   Median :196.3   Median :123.0  \n##  Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7  \n##  3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0  \n##  Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0  \n##       drat             wt             qsec             vs        \n##  Min.   :2.760   Min.   :1.513   Min.   :14.50   Min.   :0.0000  \n##  1st Qu.:3.080   1st Qu.:2.581   1st Qu.:16.89   1st Qu.:0.0000  \n##  Median :3.695   Median :3.325   Median :17.71   Median :0.0000  \n##  Mean   :3.597   Mean   :3.217   Mean   :17.85   Mean   :0.4375  \n##  3rd Qu.:3.920   3rd Qu.:3.610   3rd Qu.:18.90   3rd Qu.:1.0000  \n##  Max.   :4.930   Max.   :5.424   Max.   :22.90   Max.   :1.0000  \n##        am              gear            carb      \n##  Min.   :0.0000   Min.   :3.000   Min.   :1.000  \n##  1st Qu.:0.0000   1st Qu.:3.000   1st Qu.:2.000  \n##  Median :0.0000   Median :4.000   Median :2.000  \n##  Mean   :0.4062   Mean   :3.688   Mean   :2.812  \n##  3rd Qu.:1.0000   3rd Qu.:4.000   3rd Qu.:4.000  \n##  Max.   :1.0000   Max.   :5.000   Max.   :8.000\n```\n:::\n\n\n\n1.  Tracer l'histogramme de `mpg` (on fera varier le nombre de classes).\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(mtcars)+aes(x=mpg)+geom_histogram()\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-69-1.pdf){fig-pos='H'}\n    :::\n    \n    ```{.r .cell-code}\n    ggplot(mtcars)+aes(x=mpg)+geom_histogram(bins=10)\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-69-2.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n2.  Tracer l'histogramme de la densité.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(mtcars)+aes(x=mpg,y=..density..)+geom_histogram(bins=10)\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-70-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n3.  Tracer le diagramme en barres de `cyl`.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(mtcars)+aes(x=cyl)+geom_bar()\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-71-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n4.  Tracer le nuage de points `disp vs mpg` en utilisant une couleur différente pour chaque valeur de `cyl`.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(mtcars)+aes(x=disp,y=mpg,color=cyl)+geom_point()\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-72-1.pdf){fig-pos='H'}\n    :::\n    \n    ```{.r .cell-code}\n    ggplot(mtcars)+aes(x=disp,y=mpg,color=as.factor(cyl))+\n      geom_point()+labs(color=\"cyl\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-72-2.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n5.  Ajouter le lisseur linéaire sur le graphe (un lisseur par modalité de `cyl`).\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(mtcars)+aes(x=disp,y=mpg,color=as.factor(cyl))+geom_point()+\n      geom_smooth(method=\"lm\")+labs(color=\"cyl\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-73-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n:::\n\n::: {#exr-ggplot-reg-simple name=\"Résidus pour régression simple\"}\nOn souhaite visualiser les résidus dans un modèle de régression simple.\n\n1.  Générer un échantillon $(x_i,y_i),i=1,\\dots,100$ selon le modèle linéaire $$y_i=3+x_i+\\varepsilon_i$$ où les $x_i$ sont i.i.d. de loi uniforme sur $[0,1]$ et les $\\varepsilon_i$ sont i.i.d. de loi gaussienne $N(0,0.2^2)$ (utiliser **runif** et **rnorm**).\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    n <- 100\n    X <- runif(n)\n    eps <- rnorm(n,sd=0.2)\n    Y <- 3+X+eps\n    D <- data.frame(X,Y)\n    ```\n    :::\n\n\n\n2.  Tracer le nuage de points **Y vs X** et ajouter le lisseur linéaire.\n\n    ::: {.corR data-latex=\"\"}\n    On le fait d'abord \"à la main\" en calculant l'équation de la droite de régression.\n    :::\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    model <- lm(Y~.,data=D)\n    co <- coef(model)\n    D$fit <- predict(model)\n    co <- coef(lm(Y~.,data=D))\n    ggplot(D)+aes(x=X,y=Y)+geom_point()+\n      geom_abline(slope=co[2],intercept=co[1],color=\"blue\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-75-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n    ::: {.corR data-latex=\"\"}\n    On peut avoir le tracé directement avec `geom_smooth`.\n    :::\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(D)+aes(x=X,y=Y)+geom_point()+geom_smooth(method=\"lm\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-76-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n3.  Représenter les résidus : on ajoutera une ligne verticale entre chaque point et la droite de lissage (utiliser **geom_segment**).\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(D)+aes(x=X,y=Y)+geom_point()+geom_smooth(method=\"lm\")+\n      geom_segment(aes(xend=X,yend=fit))\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-77-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n:::\n\n::: {#exr-ggplot-challenge name=\"Challenge\"}\nOn considère les données **diamonds**.\n\n1.  Tracer les graphes suivants.\n\n\n\n    ::: {.cell}\n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-78-1.pdf)\n    :::\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-78-2.pdf)\n    :::\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-78-3.pdf)\n    :::\n    :::\n\n\n\n    ::: {.corR data-latex=\"\"}\n    On obtient les graphes demandés avec :\n    :::\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ggplot(data=diamonds) + geom_boxplot(aes(x=cut,y=carat,fill=cut)) \n    ggplot(data=diamonds) + geom_boxplot(aes(x=carat,y=cut,fill=cut))\n    ggplot(data=diamonds) + geom_density(aes(x=carat,y=..density..)) +\n      facet_grid(cut~.)\n    ```\n    :::\n\n\n\n2.  Ajouter sur le troisième graphe les quartiles de la variable **carat** pour chaque valeur de **cut**. On utilisera une ligne verticale.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    Q1 <- diamonds |> group_by(cut) |> \n      summarize(q1=quantile(carat,c(0.25)),q2=quantile(carat,c(0.5)),\n            q3=quantile(carat,c(0.75)))\n    quantildf <- Q1 |> pivot_longer(-cut,names_to=\"alpha\",values_to=\"quantiles\")\n    ggplot(data=diamonds) + geom_density(aes(x=carat,y=..density..)) +\n      facet_grid(cut~.) +\n      geom_vline(data=quantildf,aes(xintercept=quantiles),col=alpha(\"black\",1/2))\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-80-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n    ::: {.corR data-latex=\"\"}\n    On peut aussi l'obtenir avec **stat_boxplot** sans calculer explicitement les quartiles :\n    :::\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(data=diamonds) + aes(x=carat)+ \n      geom_density() +\n      stat_boxplot(aes(xintercept=c(..xlower..,..xmiddle..,\n                                    ..xupper..)),geom=\"vline\") + \n      facet_grid(cut~.) \n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-81-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n    ::: {.corR data-latex=\"\"}\n    ou encore avec **stat_summary** :\n    :::\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    diamonds |> ggplot(aes(x=carat)) +\n      geom_density() +\n      stat_summary(mapping=aes(y=1,xintercept=after_stat(x)),fun=\"quantile\",\n                   fun.args = list(prob=c(0.25,0.5,0.75)),\n                   geom=\"vline\",orientation=\"y\") + \n      facet_grid(cut~.) \n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-82-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n3.  En déduire le graphe suivant.\n\n\n\n    ::: {.cell}\n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-83-1.pdf)\n    :::\n    :::\n\n\n\n    ::: {.corR data-latex=\"\"}\n    On l'obtient avec\n    :::\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ggplot(data=diamonds) +\n      geom_boxplot(data=diamonds,aes(y=-0.5,x=carat,fill=cut)) +\n      geom_density(aes(x=carat,y=..density..)) +  facet_grid(cut~.) +\n      geom_vline(data=quantildf,aes(xintercept=quantiles),col=alpha(\"black\",1/2)) +\n      ylab(\"\")\n    ```\n    :::\n\n\n\n    ::: {.corR data-latex=\"\"}\n    ou encore\n    :::\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(data=diamonds) + aes(x=carat)+\n      geom_boxplot(data=diamonds,aes(y=-0.5,x=carat,fill=cut)) +\n      geom_density() +\n      stat_boxplot(aes(xintercept=c(..xlower..,..xmiddle..,\n                                ..xupper..)),geom=\"vline\") + \n      facet_grid(cut~.)+ylab(\"\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-85-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n    ::: {.corR data-latex=\"\"}\n    ou encore avec **stat_summary** :\n    :::\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    diamonds |> ggplot(aes(x=carat)) +\n      geom_boxplot(data=diamonds,aes(y=-0.5,x=carat,fill=cut)) +\n      geom_density() +\n      stat_summary(mapping=aes(y=1,xintercept=after_stat(x)),fun=\"quantile\",\n                   fun.args = list(prob=c(0.25,0.5,0.75)),\n                   geom=\"vline\",orientation=\"y\") + \n      facet_grid(cut~.) + ylab(\"\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](04-ggplot_files/figure-pdf/unnamed-chunk-86-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n:::\n",
    "supporting": [
      "04-ggplot_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}