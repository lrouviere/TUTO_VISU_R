{
  "hash": "0a0ccad8b22ec72c0ac0e570972363d2",
  "result": {
    "markdown": "\n::: {.content-visible when-format=\"html\"}\n::: {.cell}\n\\newcommand{\\prob}{\\mathbf P}\n\\newcommand{\\lt}{<}\n\\newcommand{\\mt}{>}\n:::\n\n```{=html}\n<style>\ndiv.correction {\n  color: black;\n  background-color: #F0F0F0;\n  font-style: normal;\n  /*display: none;*/\n}\n\n.corR {\n  font-style: italic;\n  /*display: none;*/\n}\n</style>\n```\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\\solntrue\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n# Manipuler les données avec dplyr {#sec-dplyr}\n\nLes données sont souvent le point de départ d'une étude statistique. Elles sont généralement d'abord stockées dans des fichiers (txt, xls, csv) et une des premières étapes est d'amener ces données dans **R** et de les affecter à un objet de type **dataframe**. Il est par conséquent très important connaître et maîtriser les opérations qui permettent de réaliser ces importations. Nous présentons tout d'abord quelques fonctions qui permettent de faire ces importations avant de présenter le package **dplyr** qui offre une syntaxe claire pour manipuler des données (correctement importées).\n\n## Importer des données\n\nLes fonctions **read.table** et **read.csv** sont les fonctions standards de **R** pour importer des données à partir de fichiers `.txt` ou `.csv`. Il est important de bien gérer le `chemin du répertoire` où se trouve le fichier. On peut le spécifier explicitement ou utiliser des fonctions comme **file.path** :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npath <- file.path(\"data/\", \"piscines.csv\") #premier : répertoire, deuxième : fichier\npiscines <- read.csv(path)\nclass(piscines)\n## [1] \"data.frame\"\nsummary(piscines)\n##      Name             Address             Latitude        Longitude    \n##  Length:20          Length:20          Min.   :-27.61   Min.   :152.9  \n##  Class :character   Class :character   1st Qu.:-27.55   1st Qu.:153.0  \n##  Mode  :character   Mode  :character   Median :-27.49   Median :153.0  \n##                                        Mean   :-27.49   Mean   :153.0  \n##                                        3rd Qu.:-27.45   3rd Qu.:153.1  \n##                                        Max.   :-27.31   Max.   :153.2\n```\n:::\n\n\nIl existe plusieurs **options importantes** dans **read.csv**, notamment\n\n-   **sep** : le caractère de séparation (espace, virgule...)\n-   **dec** : le caractère pour le séparateur décimal (vigule, point...)\n-   **header** : logique pour indiquer si le nom des variables est spécifié à la première ligne du fichier\n-   **row.names** : vecteurs des identifiants (si besoin)\n-   **na.strings** : vecteur de caractères pour repérer les données manquantes.\n-   ...\n\nLe package **readr** du tidyverse propose d'autres fonctions comme **read_csv** ou **read_delim**. Il n'y a pas de différences énormes avec les fonctions standards, les objets créés sont des **tibbles** et plus des **dataframes** (même si les tibbles sont des dataframes...). Par exemple\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\npiscines <- read_csv(\"data/piscines.csv\")\nsummary(piscines)\n##      Name             Address             Latitude        Longitude    \n##  Length:20          Length:20          Min.   :-27.61   Min.   :152.9  \n##  Class :character   Class :character   1st Qu.:-27.55   1st Qu.:153.0  \n##  Mode  :character   Mode  :character   Median :-27.49   Median :153.0  \n##                                        Mean   :-27.49   Mean   :153.0  \n##                                        3rd Qu.:-27.45   3rd Qu.:153.1  \n##                                        Max.   :-27.31   Max.   :153.2\nclass(piscines)\n## [1] \"spec_tbl_df\" \"tbl_df\"      \"tbl\"         \"data.frame\"\n```\n:::\n\n\nEnfin si on n'est pas très à l'aise avec ces fonctions, on pourra utiliser le bouton `Import Dataset` qui se trouve dans l'onglet `Environment` de **RStudio**. Cette manière de procédé fonctionne pour des jeux de données \"propres\". Si les bases contiennent trop de spécificités, on devra utiliser les fonctions présentées précédemment avec les bonnes options.\n\n::: {#exr-exo-import1 name=\"Premières importations avec readr\"}\nOn étudie les fonctions classiques permettant d'importer des données.\n\n1.  Importer les données qui se trouvent dans le fichier **mydata.csv**. On utilisera les fonctions `read_csv`, `read_csv2` et `read_delim` avec les options par défaut et on comparera les sorties.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    read_csv(\"data/mydata.csv\")\n    ## # A tibble: 3 × 1\n    ##   `surname;height;weight;feet_size;sex`\n    ##   <chr>                                \n    ## 1 tony;184;80;9.5;M                    \n    ## 2 james;175.5;78;8.5;M                 \n    ## 3 john;158;72;8;M\n    read_csv2(\"data/mydata.csv\")\n    ## # A tibble: 3 × 5\n    ##   surname height weight feet_size sex  \n    ##   <chr>    <dbl>  <dbl>     <dbl> <chr>\n    ## 1 tony       184     80        95 M    \n    ## 2 james     1755     78        85 M    \n    ## 3 john       158     72         8 M\n    read_delim(\"data/mydata.csv\")\n    ## # A tibble: 3 × 5\n    ##   surname height weight feet_size sex  \n    ##   <chr>    <dbl>  <dbl>     <dbl> <chr>\n    ## 1 tony      184      80       9.5 M    \n    ## 2 james     176.     78       8.5 M    \n    ## 3 john      158      72       8   M\n    ```\n    :::\n\n\n\n    ::: {.corR data-latex=\"\"}\n    `read_csv` n'utilise pas le bon séparateur par défaut, `read_csv2` ne lit pas correctement le symbole pour la décimale, `read_delim` fonctionne bien pour ce fichier (sinon il aurait fallu ajouter l'option `delim`).\n    :::\n\n2.  Importer les données qui se trouvent dans le fichier **mydata2.csv**.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    data2 <- read_delim(\"data/mydata2.csv\",delim=\" \")\n    data2\n    ## # A tibble: 4 × 4\n    ##   height weight  size sex  \n    ##   <chr>  <chr>  <dbl> <chr>\n    ## 1 184    80       9.5 M    \n    ## 2 175.5  78       8.5 M    \n    ## 3 .      72       8   M    \n    ## 4 178    .        7   F\n    summary(data2)\n    ##     height             weight               size          sex           \n    ##  Length:4           Length:4           Min.   :7.00   Length:4          \n    ##  Class :character   Class :character   1st Qu.:7.75   Class :character  \n    ##  Mode  :character   Mode  :character   Median :8.25   Mode  :character  \n    ##                                        Mean   :8.25                     \n    ##                                        3rd Qu.:8.75                     \n    ##                                        Max.   :9.50\n    ```\n    :::\n\n    ::: {.corR data-latex=\"\"}\n    Les variable `height` et `weight` sont interprétées comme des variables qualitatives, cela vient du fait qu'il y a des données manquante mal lues.\n    :::\n\n4.  Ce fichier contient des données manquantes (identifiées par un point). A l'aide de l'option **na**, refaire l'importation en identifiant correctement les données manquantes.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    data2 <- read_delim(\"data/mydata2.csv\",delim=\" \",na=\".\")\n    data2\n    ## # A tibble: 4 × 4\n    ##   height weight  size sex  \n    ##    <dbl>  <dbl> <dbl> <chr>\n    ## 1   184      80   9.5 M    \n    ## 2   176.     78   8.5 M    \n    ## 3    NA      72   8   M    \n    ## 4   178      NA   7   F\n    summary(data2)\n    ##      height          weight           size          sex           \n    ##  Min.   :175.5   Min.   :72.00   Min.   :7.00   Length:4          \n    ##  1st Qu.:176.8   1st Qu.:75.00   1st Qu.:7.75   Class :character  \n    ##  Median :178.0   Median :78.00   Median :8.25   Mode  :character  \n    ##  Mean   :179.2   Mean   :76.67   Mean   :8.25                     \n    ##  3rd Qu.:181.0   3rd Qu.:79.00   3rd Qu.:8.75                     \n    ##  Max.   :184.0   Max.   :80.00   Max.   :9.50                     \n    ##  NA's   :1       NA's   :1\n    ```\n    :::\n\n\n5.  Changer les **levels** de la variable `sex` en **woman** et **man** (on pourra utiliser la fonction **levels**).\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    data22 <- data2\n    ```\n    :::\n\n\n    -   1ère façon :\n\n\n        ::: {.cell teacher='true'}\n        \n        ```{.r .cell-code}\n        data2$sex <- as.factor(data2$sex)\n        levels(data2$sex) <- c(\"woman\",\"man\")\n        data2\n        ## # A tibble: 4 × 4\n        ##   height weight  size sex  \n        ##    <dbl>  <dbl> <dbl> <fct>\n        ## 1   184      80   9.5 man  \n        ## 2   176.     78   8.5 man  \n        ## 3    NA      72   8   man  \n        ## 4   178      NA   7   woman\n        ```\n        :::\n\n\n    -   2ème façon avec **recode_factor** du package `forcats` :\n\n\n        ::: {.cell teacher='true'}\n        \n        ```{.r .cell-code}\n        data22$sex <- recode_factor(data2$sex,\"F\"=\"woman\",\"M\"=\"man\")\n        data22\n        ## # A tibble: 4 × 4\n        ##   height weight  size sex  \n        ##    <dbl>  <dbl> <dbl> <fct>\n        ## 1   184      80   9.5 man  \n        ## 2   176.     78   8.5 man  \n        ## 3    NA      72   8   man  \n        ## 4   178      NA   7   woman\n        ```\n        :::\n\n:::\n\n::: {#exr-exo-importclassique name=\"Importer avec read.csv\"}\nRefaire l'exercice précédent avec la fonction **read.csv**.\n\n::: {.corR data-latex=\"\"}\nOn commence avec les paramètres par défaut :\n:::\n\n\n::: {.cell teacher='true'}\n\n```{.r .cell-code}\ndata1 <- read.csv(\"data/mydata.csv\")\nsummary(data1)\n##  surname.height.weight.feet_size.sex\n##  Length:3                           \n##  Class :character                   \n##  Mode  :character\n```\n:::\n\n\n::: {.corR data-latex=\"\"}\nLe séparateur n'est pas bien défini ! On corrige :\n:::\n\n\n::: {.cell teacher='true'}\n\n```{.r .cell-code}\ndata1 <- read.csv(\"data/mydata.csv\",sep=\";\",\n                  dec=\".\",row.names = 1)\nsummary(data1)\n##      height          weight        feet_size         sex           \n##  Min.   :158.0   Min.   :72.00   Min.   :8.000   Length:3          \n##  1st Qu.:166.8   1st Qu.:75.00   1st Qu.:8.250   Class :character  \n##  Median :175.5   Median :78.00   Median :8.500   Mode  :character  \n##  Mean   :172.5   Mean   :76.67   Mean   :8.667                     \n##  3rd Qu.:179.8   3rd Qu.:79.00   3rd Qu.:9.000                     \n##  Max.   :184.0   Max.   :80.00   Max.   :9.500\n```\n:::\n\n::: {.corR data-latex=\"\"}\nPour le second fichier on fait :\n:::\n\n\n::: {.cell teacher='true'}\n\n```{.r .cell-code}\ndata2 <- read.csv(\"data/mydata2.csv\",sep=\"\",na.strings = \".\")\ndata2$sex <- recode_factor(data2$sex,\"F\"=\"woman\",\"M\"=\"man\")\ndata2\n##   height weight size   sex\n## 1  184.0     80  9.5   man\n## 2  175.5     78  8.5   man\n## 3     NA     72  8.0   man\n## 4  178.0     NA  7.0 woman\nsummary(data2)\n##      height          weight           size         sex   \n##  Min.   :175.5   Min.   :72.00   Min.   :7.00   woman:1  \n##  1st Qu.:176.8   1st Qu.:75.00   1st Qu.:7.75   man  :3  \n##  Median :178.0   Median :78.00   Median :8.25            \n##  Mean   :179.2   Mean   :76.67   Mean   :8.25            \n##  3rd Qu.:181.0   3rd Qu.:79.00   3rd Qu.:8.75            \n##  Max.   :184.0   Max.   :80.00   Max.   :9.50            \n##  NA's   :1       NA's   :1\n```\n:::\n\n\n:::\n\n::: {#exr-exo-import2 name=\"Jointure de tables\"}\nOn considère les 3 jeux de données suivants, au format **tibble** :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- tibble(name=c(\"Mary\",\"Peter\",\"John\",\"July\"),age=c(18,25,21,43))\ndf2 <- tibble(name=c(\"Zac\",\"Julian\"),age=c(23,48))\ndf3 <- tibble(size=c(154,178,182,134,142),name1=c(\"Peter\",\"Mary\",\"July\",\"John\",\"stef\"))\ndf1\n## # A tibble: 4 × 2\n##   name    age\n##   <chr> <dbl>\n## 1 Mary     18\n## 2 Peter    25\n## 3 John     21\n## 4 July     43\ndf2\n## # A tibble: 2 × 2\n##   name     age\n##   <chr>  <dbl>\n## 1 Zac       23\n## 2 Julian    48\ndf3\n## # A tibble: 5 × 2\n##    size name1\n##   <dbl> <chr>\n## 1   154 Peter\n## 2   178 Mary \n## 3   182 July \n## 4   134 John \n## 5   142 stef\n```\n:::\n\n\nOn souhaite assembler ces tables en utilisant les *fonctions de jointure* du **tidyverse** (**left_join**, **full_join** par exemple). On pourra consulter la cheatsheet **Data transformation with dplyr** (*help -\\> cheatsheets -\\> ...*).\n\n1.  Assembler `df1` avec `df2` en utilisant **bind_rows** et calculer la moyenne de la variable `age`. On appellera `df` cette nouvelle table.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    df <- bind_rows(df1,df2)\n    mean(df$age)\n    ## [1] 29.66667\n    ```\n    :::\n\n\n2.  Assembler `df` avec `df3` en utilisant **full_join**.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    a1 <- full_join(df,df3,by=c(\"name\"=\"name1\"))\n    a1\n    ## # A tibble: 7 × 3\n    ##   name     age  size\n    ##   <chr>  <dbl> <dbl>\n    ## 1 Mary      18   178\n    ## 2 Peter     25   154\n    ## 3 John      21   134\n    ## 4 July      43   182\n    ## 5 Zac       23    NA\n    ## 6 Julian    48    NA\n    ## 7 stef      NA   142\n    ```\n    :::\n\n\n3.  Faire la même chose avec **inner_join**.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    a2 <- inner_join(df,df3,by=c(\"name\"=\"name1\"))\n    a2\n    ## # A tibble: 4 × 3\n    ##   name    age  size\n    ##   <chr> <dbl> <dbl>\n    ## 1 Mary     18   178\n    ## 2 Peter    25   154\n    ## 3 John     21   134\n    ## 4 July     43   182\n    ```\n    :::\n\n\n4.  Expliquer les différences entre **full_join** et **inner_join**.\n\n    ::: {.corR data-latex=\"\"}\n    **inner_join** retient uniquement les individus pour lesquels `age` **et** `size` ont été observés. **full_join** garde tous les individus, des **NA** sont ajoutés lorsque la variable n'est pas observée.\n    :::\n:::\n\n## Le package dplyr\n\n**dplyr** est un package du `tidyverse` qui permet de faciliter la manipulation des données. Il propose une **syntaxe claire** (basée sur une `grammaire`) pour travailler sur les données. On pourra trouver des informations à cet url <https://spark.rstudio.com/dplyr.html> ou sur la [cheatsheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf).\n\nNous avons vu quelques opérations standards pour manipuler les données. Par exemple, on peut obtenir les **Longitude** et **Latitude** des piscines ayant une *Longitude* supérieure à 153 avec\n\n\n::: {.cell}\n\n```{.r .cell-code}\npiscines[piscines$Longitude>153,c(\"Longitude\",\"Latitude\")]\n## # A tibble: 16 × 2\n##    Longitude Latitude\n##        <dbl>    <dbl>\n##  1      153.    -27.6\n##  2      153.    -27.5\n##  3      153.    -27.4\n##  4      153.    -27.5\n##  5      153.    -27.5\n##  6      153.    -27.5\n##  7      153.    -27.6\n##  8      153.    -27.5\n##  9      153.    -27.5\n## 10      153.    -27.5\n## 11      153.    -27.5\n## 12      153.    -27.4\n## 13      153.    -27.6\n## 14      153.    -27.3\n## 15      153.    -27.5\n## 16      153.    -27.5\n```\n:::\n\n\n**dplyr** propose de faire la même chose avec une syntaxe plus claire\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) #ou library(dplyr)\npiscines |> select(Longitude,Latitude) |> filter(Longitude>153)\n## # A tibble: 16 × 2\n##    Longitude Latitude\n##        <dbl>    <dbl>\n##  1      153.    -27.6\n##  2      153.    -27.5\n##  3      153.    -27.4\n##  4      153.    -27.5\n##  5      153.    -27.5\n##  6      153.    -27.5\n##  7      153.    -27.6\n##  8      153.    -27.5\n##  9      153.    -27.5\n## 10      153.    -27.5\n## 11      153.    -27.5\n## 12      153.    -27.4\n## 13      153.    -27.6\n## 14      153.    -27.3\n## 15      153.    -27.5\n## 16      153.    -27.5\n```\n:::\n\n\nLe code est plus efficace et facile à lire.\n\n**dplyr** propose une `grammaire` dont les principaux `verbes` sont :\n\n-   **select()** : sélectionner des colonnes (variables)\n-   **filter()** : filtrer des lignes (individus)\n-   **arrange()** : ordonner des lignes\n-   **mutate()** : créer des nouvelles colonnes (nouvelles variables)\n-   **summarise()** : calculer des résumés numériques (ou résumés statistiques)\n-   **group_by()** : effectuer des opérations pour des groupes d'individus\n\nNous les présentons dans la partie suivante.\n\n### Les principaux verbes dplyr\n\n#### Le verbe `select()` {.unnumbered}\n\nIl permet de sélectionner des variables (colonnes) :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(df, VAR1, VAR2, ...)\n```\n:::\n\n\nPar exemple,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoord <- select(piscines, Latitude, Longitude)\nhead(piscines, n=2)\n## # A tibble: 2 × 4\n##   Name                        Address                         Latitude Longitude\n##   <chr>                       <chr>                              <dbl>     <dbl>\n## 1 Acacia Ridge Leisure Centre 1391 Beaudesert Road, Acacia R…    -27.6      153.\n## 2 Bellbowrie Pool             Sugarwood Street, Bellbowrie       -27.6      153.\nhead(coord, n=2)\n## # A tibble: 2 × 2\n##   Latitude Longitude\n##      <dbl>     <dbl>\n## 1    -27.6      153.\n## 2    -27.6      153.\n```\n:::\n\n\nOn peut utiliser les **helper functions** (**begins_with**, **end_with**, **contains**, **matches**) pour des sélections plus précises basées sur le nom des variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoord <- select(piscines, ends_with(\"tude\"))\nhead(coord, n=2)\n## # A tibble: 2 × 2\n##   Latitude Longitude\n##      <dbl>     <dbl>\n## 1    -27.6      153.\n## 2    -27.6      153.\n```\n:::\n\n\n#### Le verbe `mutate()` {.unnumbered}\n\nIl permet de créer des nouvelles variables\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(df, NEW.VAR = expression(VAR1, VAR2, ...))\n```\n:::\n\n\nPar exemple\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- mutate(piscines, phrase=paste(\"Swimming pool\", Name, \"is located at the address\", Address))\nselect(df,phrase)\n## # A tibble: 20 × 1\n##    phrase                                                                       \n##    <chr>                                                                        \n##  1 Swimming pool Acacia Ridge Leisure Centre is located at the address 1391 Bea…\n##  2 Swimming pool Bellbowrie Pool is located at the address Sugarwood Street, Be…\n##  3 Swimming pool Carole Park is located at the address Cnr Boundary Road and Wa…\n##  4 Swimming pool Centenary Pool (inner City) is located at the address 400 Greg…\n##  5 Swimming pool Chermside Pool is located at the address 375 Hamilton Road, Ch…\n##  6 Swimming pool Colmslie Pool (Morningside) is located at the address 400 Lytt…\n##  7 Swimming pool Spring Hill Baths (inner City) is located at the address 14 To…\n##  8 Swimming pool Dunlop Park Pool (Corinda) is located at the address 794 Oxley…\n##  9 Swimming pool Fortitude Valley Pool is located at the address 432 Wickham St…\n## 10 Swimming pool Hibiscus Sports Complex (upper MtGravatt) is located at the ad…\n## 11 Swimming pool Ithaca Pool ( Paddington) is located at the address 131 Caxton…\n## 12 Swimming pool Jindalee Pool is located at the address 11 Yallambee Road, Jin…\n## 13 Swimming pool Manly Pool is located at the address 1 Fairlead Crescent, Manly\n## 14 Swimming pool Mt Gravatt East Aquatic Centre is located at the address Cnr w…\n## 15 Swimming pool Musgrave Park Pool (South Brisbane) is located at the address …\n## 16 Swimming pool Newmarket Pool is located at the address 71 Alderson Stret, Ne…\n## 17 Swimming pool Runcorn Pool is located at the address 37 Bonemill Road, Runco…\n## 18 Swimming pool Sandgate Pool is located at the address 231 Flinders Parade, S…\n## 19 Swimming pool Langlands Parks Pool (Stones Corner) is located at the address…\n## 20 Swimming pool Yeronga Park Pool is located at the address 81 School Road, Ye…\n```\n:::\n\n\nOn peut également créer plusieurs variables avec un seul **mutate** :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(piscines,\n       phrase = paste(\"Swimming pool\", Name, \"is located at the address\", Address),\n       unused = Longitude + Latitude\n)\n## # A tibble: 20 × 6\n##    Name                                 Address Latitude Longitude phrase unused\n##    <chr>                                <chr>      <dbl>     <dbl> <chr>   <dbl>\n##  1 Acacia Ridge Leisure Centre          1391 B…    -27.6      153. Swimm…   125.\n##  2 Bellbowrie Pool                      Sugarw…    -27.6      153. Swimm…   125.\n##  3 Carole Park                          Cnr Bo…    -27.6      153. Swimm…   125.\n##  4 Centenary Pool (inner City)          400 Gr…    -27.5      153. Swimm…   126.\n##  5 Chermside Pool                       375 Ha…    -27.4      153. Swimm…   126.\n##  6 Colmslie Pool (Morningside)          400 Ly…    -27.5      153. Swimm…   126.\n##  7 Spring Hill Baths (inner City)       14 Tor…    -27.5      153. Swimm…   126.\n##  8 Dunlop Park Pool (Corinda)           794 Ox…    -27.5      153. Swimm…   125.\n##  9 Fortitude Valley Pool                432 Wi…    -27.5      153. Swimm…   126.\n## 10 Hibiscus Sports Complex (upper MtGr… 90 Klu…    -27.6      153. Swimm…   126.\n## 11 Ithaca Pool ( Paddington)            131 Ca…    -27.5      153. Swimm…   126.\n## 12 Jindalee Pool                        11 Yal…    -27.5      153. Swimm…   125.\n## 13 Manly Pool                           1 Fair…    -27.5      153. Swimm…   126.\n## 14 Mt Gravatt East Aquatic Centre       Cnr we…    -27.5      153. Swimm…   126.\n## 15 Musgrave Park Pool (South Brisbane)  100 Ed…    -27.5      153. Swimm…   126.\n## 16 Newmarket Pool                       71 Ald…    -27.4      153. Swimm…   126.\n## 17 Runcorn Pool                         37 Bon…    -27.6      153. Swimm…   125.\n## 18 Sandgate Pool                        231 Fl…    -27.3      153. Swimm…   126.\n## 19 Langlands Parks Pool (Stones Corner) 5 Pani…    -27.5      153. Swimm…   126.\n## 20 Yeronga Park Pool                    81 Sch…    -27.5      153. Swimm…   125.\n```\n:::\n\n\n#### Le verbe `filter()` {.unnumbered}\n\nIl permet de sélectionner (filtrer) des individus (lignes) :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(df, TEST)\n```\n:::\n\n\nPar exemple\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- filter(piscines, Longitude>153.02)\nselect(p1,Longitude)\n## # A tibble: 12 × 1\n##    Longitude\n##        <dbl>\n##  1      153.\n##  2      153.\n##  3      153.\n##  4      153.\n##  5      153.\n##  6      153.\n##  7      153.\n##  8      153.\n##  9      153.\n## 10      153.\n## 11      153.\n## 12      153.\n```\n:::\n\n\nou (on sélectionne les piscines dont le nom contient **Pool**)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- filter(piscines, !grepl(\"Pool\", Name))\nselect(df,Name)\n## # A tibble: 5 × 1\n##   Name                                     \n##   <chr>                                    \n## 1 Acacia Ridge Leisure Centre              \n## 2 Carole Park                              \n## 3 Spring Hill Baths (inner City)           \n## 4 Hibiscus Sports Complex (upper MtGravatt)\n## 5 Mt Gravatt East Aquatic Centre\n```\n:::\n\n\nou (on sélectionne les piscines avec une longitude plus grande que 153.02 **ou** une latitude plus petite que -27.488)\n\n\n::: {.cell}\n\n```{.r .cell-code}\np2 <- filter(piscines, Longitude>153.02 | Latitude < -27.488)\nselect(p2, Longitude, Latitude)\n## # A tibble: 17 × 2\n##    Longitude Latitude\n##        <dbl>    <dbl>\n##  1      153.    -27.6\n##  2      153.    -27.6\n##  3      153.    -27.6\n##  4      153.    -27.5\n##  5      153.    -27.4\n##  6      153.    -27.5\n##  7      153.    -27.5\n##  8      153.    -27.5\n##  9      153.    -27.5\n## 10      153.    -27.6\n## 11      153.    -27.5\n## 12      153.    -27.5\n## 13      153.    -27.5\n## 14      153.    -27.6\n## 15      153.    -27.3\n## 16      153.    -27.5\n## 17      153.    -27.5\n```\n:::\n\n\nOn peut également utiliser la fonction **slice** pour choisir des individus à partir de leurs indices :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslice(piscines,5:8)\n## # A tibble: 4 × 4\n##   Name                           Address                      Latitude Longitude\n##   <chr>                          <chr>                           <dbl>     <dbl>\n## 1 Chermside Pool                 375 Hamilton Road, Chermside    -27.4      153.\n## 2 Colmslie Pool (Morningside)    400 Lytton Road, Morningside    -27.5      153.\n## 3 Spring Hill Baths (inner City) 14 Torrington Street, Sprin…    -27.5      153.\n## 4 Dunlop Park Pool (Corinda)     794 Oxley Road, Corinda         -27.5      153.\n```\n:::\n\n\n#### Le verbe `arrange()` {.unnumbered}\n\nIl permet d'ordonner les individus en fonction d'une variable\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange(df, VAR) #tri croissant\n```\n:::\n\n\nou\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange(df, desc(VAR)) #tri décroissant\n```\n:::\n\n\nPar exemple\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange(piscines, Longitude)\n## # A tibble: 20 × 4\n##    Name                                      Address          Latitude Longitude\n##    <chr>                                     <chr>               <dbl>     <dbl>\n##  1 Bellbowrie Pool                           Sugarwood Stree…    -27.6      153.\n##  2 Carole Park                               Cnr Boundary Ro…    -27.6      153.\n##  3 Jindalee Pool                             11 Yallambee Ro…    -27.5      153.\n##  4 Dunlop Park Pool (Corinda)                794 Oxley Road,…    -27.5      153.\n##  5 Newmarket Pool                            71 Alderson Str…    -27.4      153.\n##  6 Ithaca Pool ( Paddington)                 131 Caxton Stre…    -27.5      153.\n##  7 Musgrave Park Pool (South Brisbane)       100 Edmonstone …    -27.5      153.\n##  8 Yeronga Park Pool                         81 School Road,…    -27.5      153.\n##  9 Spring Hill Baths (inner City)            14 Torrington S…    -27.5      153.\n## 10 Centenary Pool (inner City)               400 Gregory Ter…    -27.5      153.\n## 11 Acacia Ridge Leisure Centre               1391 Beaudesert…    -27.6      153.\n## 12 Chermside Pool                            375 Hamilton Ro…    -27.4      153.\n## 13 Fortitude Valley Pool                     432 Wickham Str…    -27.5      153.\n## 14 Langlands Parks Pool (Stones Corner)      5 Panitya Stree…    -27.5      153.\n## 15 Sandgate Pool                             231 Flinders Pa…    -27.3      153.\n## 16 Hibiscus Sports Complex (upper MtGravatt) 90 Klumpp Road,…    -27.6      153.\n## 17 Runcorn Pool                              37 Bonemill Roa…    -27.6      153.\n## 18 Colmslie Pool (Morningside)               400 Lytton Road…    -27.5      153.\n## 19 Mt Gravatt East Aquatic Centre            Cnr wecker Road…    -27.5      153.\n## 20 Manly Pool                                1 Fairlead Cres…    -27.5      153.\n```\n:::\n\n\nou\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange(piscines, desc(Longitude))\n## # A tibble: 20 × 4\n##    Name                                      Address          Latitude Longitude\n##    <chr>                                     <chr>               <dbl>     <dbl>\n##  1 Manly Pool                                1 Fairlead Cres…    -27.5      153.\n##  2 Mt Gravatt East Aquatic Centre            Cnr wecker Road…    -27.5      153.\n##  3 Colmslie Pool (Morningside)               400 Lytton Road…    -27.5      153.\n##  4 Runcorn Pool                              37 Bonemill Roa…    -27.6      153.\n##  5 Hibiscus Sports Complex (upper MtGravatt) 90 Klumpp Road,…    -27.6      153.\n##  6 Sandgate Pool                             231 Flinders Pa…    -27.3      153.\n##  7 Langlands Parks Pool (Stones Corner)      5 Panitya Stree…    -27.5      153.\n##  8 Fortitude Valley Pool                     432 Wickham Str…    -27.5      153.\n##  9 Chermside Pool                            375 Hamilton Ro…    -27.4      153.\n## 10 Acacia Ridge Leisure Centre               1391 Beaudesert…    -27.6      153.\n## 11 Centenary Pool (inner City)               400 Gregory Ter…    -27.5      153.\n## 12 Spring Hill Baths (inner City)            14 Torrington S…    -27.5      153.\n## 13 Yeronga Park Pool                         81 School Road,…    -27.5      153.\n## 14 Musgrave Park Pool (South Brisbane)       100 Edmonstone …    -27.5      153.\n## 15 Ithaca Pool ( Paddington)                 131 Caxton Stre…    -27.5      153.\n## 16 Newmarket Pool                            71 Alderson Str…    -27.4      153.\n## 17 Dunlop Park Pool (Corinda)                794 Oxley Road,…    -27.5      153.\n## 18 Jindalee Pool                             11 Yallambee Ro…    -27.5      153.\n## 19 Carole Park                               Cnr Boundary Ro…    -27.6      153.\n## 20 Bellbowrie Pool                           Sugarwood Stree…    -27.6      153.\n```\n:::\n\n\n### Les verbes `summarize` et `groub_by`\n\nLes verbes précédents permettent de manipuler les données en sélectionnant des individus ou variables essentiellement. Ces deux nouveaux verbes vont permettre de calculer des indicateurs statistiques sur un jeu de données.\n\n#### Le verbe `summarize` (ou `summarise`) {.unnumbered}\n\nIl permet de créer des nouveaux jeux de données qui contiennent des résumés statistiques du jeu de données initial comme la moyenne, variance, médiane de variables. Par exemple\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(piscines,\n          mean_long = mean(Longitude),\n          med_lat = median(Latitude),\n          min_lat = min(Latitude),\n          sum_long = sum(Longitude)\n)\n## # A tibble: 1 × 4\n##   mean_long med_lat min_lat sum_long\n##       <dbl>   <dbl>   <dbl>    <dbl>\n## 1      153.   -27.5   -27.6    3061.\n```\n:::\n\n\n**dplyr** contient également les fonction suivantes (souvent utilisées en statistique) :\n\n1.  `n()` : nombre de lignes (individus d'un jeu de données).\n2.  `n_distinct()` : nombre d'éléments distincts dans un vecteur.\n3.  `fisrt()` et `last()` : premier et dernier élément d'un vecteur.\n\nPar exemple, on obtient le nombre de piscines dans le jeu de données, et la longitude de la dernière piscine avec\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(piscines,n())\n## # A tibble: 1 × 1\n##   `n()`\n##   <int>\n## 1    20\nsummarise(piscines,last(Longitude))\n## # A tibble: 1 × 1\n##   `last(Longitude)`\n##               <dbl>\n## 1              153.\n```\n:::\n\n\nOn peut aussi utiliser **summarise_all**, **summarise_at** qui vont permettre de répéter les mêmes opérations sur plusieurs variables. Par exemple\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise_at(piscines,3:4,mean)\n## # A tibble: 1 × 2\n##   Latitude Longitude\n##      <dbl>     <dbl>\n## 1    -27.5      153.\n```\n:::\n\n\n#### Regrouper des données avec `Group_by` {.unnumbered}\n\n**group_by** permet d'appliquer une ou des opérations à des groupes de données (ou d'individus). Par exemple, imaginons que l'on souhaite calculer les longitudes moyennes des piscines scindées en 2 groupes : petites et grande latitudes. On créé d'abord une variable **lat_dis** qui permet d'identifier les latitudes (petite ou grande) :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlat_mean <- piscines |> summarise(mean(Latitude))\npisc1 <- piscines |> mutate(lat_dis=factor(Latitude>as.numeric(lat_mean)))\nlevels(pisc1$lat_dis) <- c(\"Low\",\"High\")\n```\n:::\n\n\nIl reste maintenant à utiliser **group_by** pour obtenir les longitudes moyennes des 2 groupes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(group_by(pisc1,lat_dis),mean_long=mean(Longitude))\n## # A tibble: 2 × 2\n##   lat_dis mean_long\n##   <fct>       <dbl>\n## 1 Low          153.\n## 2 High         153.\n```\n:::\n\n\n### Assembler des verbes avec l'opérateur de chainage `|>`\n\nUn des principaux intérêts de **dplyr** est bien entendu d'utiliser plusieurs verbes pour arriver au résultat souhaité. C'est ce qui est fait plus haut et nous observons que la syntaxe n'est pas facile à lire. Le package propose un **opérateur de chainage** ou **pipe opérateur** qui permet de rentre cette syntaxe plus lisible. Cet opérateur consiste à décomposer le code étape par étape et à relier ces étapes par le symbole `|>`. On peut par exemple réécrire l'exemple précédent avec :\n\n1.  Le jeu de données\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pisc1\n    ```\n    :::\n\n\n2.  Étape `group_by`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pisc1 |> group_by(lat_dis)\n    ```\n    :::\n\n\n3.  Étape `summarise`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pisc1 |> group_by(lat_dis) |> summarise(mean_long=mean(Longitude))\n    ## # A tibble: 2 × 2\n    ##   lat_dis mean_long\n    ##   <fct>       <dbl>\n    ## 1 Low          153.\n    ## 2 High         153.\n    ```\n    :::\n\n\nqui donne le résultat souhaité.\n\nCet opérateur peut être utilisé pour toutes les fonctions **R**. Il revient à considérer comme premier argument du terme à droite du pipe le terme à gauche de ce dernier. Par exemple\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(1:10)\n## [1] 5.5\n1:10 |> mean()\n## [1] 5.5\n```\n:::\n\n\nIl est recommandé d'utiliser cet opérateur lorsque on chaîne les verbes **dplyr**, la syntaxe est beaucoup plus claire.\n\n### Quelques exercices\n\n::: {#exr-exo-dplyr-iris name=\"Dplyr sur les iris de Fisher\"}\nOn considère le jeu de données **iris**\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris <- iris |> as_tibble()\n```\n:::\n\n\nRépondre aux questions suivantes en utilisant les verbes **dplyr** et l'opérateur `|>`.\n\n1.  Sélectionner les variables `Petal.Width` et `Species`.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    iris |> select(Petal.Width,Species)\n    ## # A tibble: 150 × 2\n    ##    Petal.Width Species\n    ##          <dbl> <fct>  \n    ##  1         0.2 setosa \n    ##  2         0.2 setosa \n    ##  3         0.2 setosa \n    ##  4         0.2 setosa \n    ##  5         0.2 setosa \n    ##  6         0.4 setosa \n    ##  7         0.3 setosa \n    ##  8         0.2 setosa \n    ##  9         0.2 setosa \n    ## 10         0.1 setosa \n    ## # ℹ 140 more rows\n    ```\n    :::\n\n\n2.  Construire une table qui contient uniquement les iris d'espèce `versicolor` ou `virginica` (on pourra utiliser le symbole `|` pour la condition **ou**).\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    iris |> filter(Species==\"versicolor\" | Species==\"virginica\")\n    ## # A tibble: 100 × 5\n    ##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species   \n    ##           <dbl>       <dbl>        <dbl>       <dbl> <fct>     \n    ##  1          7           3.2          4.7         1.4 versicolor\n    ##  2          6.4         3.2          4.5         1.5 versicolor\n    ##  3          6.9         3.1          4.9         1.5 versicolor\n    ##  4          5.5         2.3          4           1.3 versicolor\n    ##  5          6.5         2.8          4.6         1.5 versicolor\n    ##  6          5.7         2.8          4.5         1.3 versicolor\n    ##  7          6.3         3.3          4.7         1.6 versicolor\n    ##  8          4.9         2.4          3.3         1   versicolor\n    ##  9          6.6         2.9          4.6         1.3 versicolor\n    ## 10          5.2         2.7          3.9         1.4 versicolor\n    ## # ℹ 90 more rows\n    ```\n    :::\n\n\n    On peut également conserver tous les iris à l'exception de l'espèce `setosa` :\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    iris |> filter(Species!=\"setosa\")\n    ## # A tibble: 100 × 5\n    ##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species   \n    ##           <dbl>       <dbl>        <dbl>       <dbl> <fct>     \n    ##  1          7           3.2          4.7         1.4 versicolor\n    ##  2          6.4         3.2          4.5         1.5 versicolor\n    ##  3          6.9         3.1          4.9         1.5 versicolor\n    ##  4          5.5         2.3          4           1.3 versicolor\n    ##  5          6.5         2.8          4.6         1.5 versicolor\n    ##  6          5.7         2.8          4.5         1.3 versicolor\n    ##  7          6.3         3.3          4.7         1.6 versicolor\n    ##  8          4.9         2.4          3.3         1   versicolor\n    ##  9          6.6         2.9          4.6         1.3 versicolor\n    ## 10          5.2         2.7          3.9         1.4 versicolor\n    ## # ℹ 90 more rows\n    ```\n    :::\n\n\n3.  Calculer le nombre d'iris de l'espèce `setosa` en utilisant **summarise**.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    iris |> filter(Species==\"setosa\") |> summarise(n())\n    ## # A tibble: 1 × 1\n    ##   `n()`\n    ##   <int>\n    ## 1    50\n    ```\n    :::\n\n\n4.  Calculer la moyenne de la variable `Petal.Width` pour les iris de l'espèce `versicolor`.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    iris |> filter(Species==\"versicolor\") |>\n      summarise(Mean_PW=mean(Petal.Width))\n    ## # A tibble: 1 × 1\n    ##   Mean_PW\n    ##     <dbl>\n    ## 1    1.33\n    ```\n    :::\n\n\n5.  Ajouter dans le jeu de données la variable `Sum_Petal` qui correspond à la somme de `Petal.Width` et `Sepal.Width`.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    iris1 <- iris\n    iris1 |> mutate(Sum_Petal=Petal.Width+Sepal.Width)\n    ## # A tibble: 150 × 6\n    ##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sum_Petal\n    ##           <dbl>       <dbl>        <dbl>       <dbl> <fct>       <dbl>\n    ##  1          5.1         3.5          1.4         0.2 setosa        3.7\n    ##  2          4.9         3            1.4         0.2 setosa        3.2\n    ##  3          4.7         3.2          1.3         0.2 setosa        3.4\n    ##  4          4.6         3.1          1.5         0.2 setosa        3.3\n    ##  5          5           3.6          1.4         0.2 setosa        3.8\n    ##  6          5.4         3.9          1.7         0.4 setosa        4.3\n    ##  7          4.6         3.4          1.4         0.3 setosa        3.7\n    ##  8          5           3.4          1.5         0.2 setosa        3.6\n    ##  9          4.4         2.9          1.4         0.2 setosa        3.1\n    ## 10          4.9         3.1          1.5         0.1 setosa        3.2\n    ## # ℹ 140 more rows\n    ```\n    :::\n\n\n6.  Calculer la moyenne et la variance de la variable `Pepal.Length` pour chaque espèce (on pourra utiliser **group_by**).\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    iris |> group_by(Species) |>\n      summarise(mean_PL=mean(Petal.Length),var_PL=var(Petal.Length)) |>\n      mutate(var_PL=round(var_PL,3))\n    ## # A tibble: 3 × 3\n    ##   Species    mean_PL var_PL\n    ##   <fct>        <dbl>  <dbl>\n    ## 1 setosa        1.46  0.03 \n    ## 2 versicolor    4.26  0.221\n    ## 3 virginica     5.55  0.305\n    ```\n    :::\n\n:::\n\n::: {#exr-exo-dplyr-hflights name=\"Traffic aérien aux USA\"}\nOn considère la table **hflights** qui contient des informations sur les vols au départ des aéroports Houston airports IAH (George Bush Intercontinental) et HOU (Houston Hobby):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(hflights)\nhflights <- as_tibble(hflights)\n```\n:::\n\n\nLa variable `Unique Carrier` renseigne sur la compagnie du vol. On recode cette variable afin que la compagnie soit plus explicite :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlut1 <- c(\"AA\" = \"American\", \"AS\" = \"Alaska\", \"B6\" = \"JetBlue\", \"CO\" = \"Continental\",\n         \"DL\" = \"Delta\", \"OO\" = \"SkyWest\", \"UA\" = \"United\", \"US\" = \"US_Airways\", \n         \"WN\" = \"Southwest\", \"EV\" = \"Atlantic_Southeast\", \"F9\" = \"Frontier\", \n         \"FL\" = \"AirTran\", \"MQ\" = \"American_Eagle\", \"XE\" = \"ExpressJet\", \"YV\" = \"Mesa\")\n```\n:::\n\n\nOn fait de même pour la variable `CancellationCode` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlut2 <- c(\"A\" = \"carrier\", \"B\" = \"weather\", \"C\" = \"FFA\", \"D\" = \"security\", \"E\" = \"not cancelled\")\n```\n:::\n\n\nOn effectue maintenant les changements dans la table pour obtenir une nouvelle version de **hflights** :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhflights1 <- hflights\nhflights1$UniqueCarrier <- lut1[hflights1$UniqueCarrier]\nhflights1$CancellationCode[hflights1$CancellationCode==\"\"] <- \"Z\"\nhflights1$CancellationCode <- lut2[hflights1$CancellationCode]\n```\n:::\n\n\nA partir de maintenant, on travaille avec **hflights1**.\n\n1.  Sélectionner les variables qui se situent entre `Origin` et `Cancelled` de différentes façons.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ind <- match(c(\"Origin\",\"Cancelled\"),names(hflights1))\n    hflights1 |> select(seq(ind[1],ind[2]))\n    ## # A tibble: 227,496 × 6\n    ##    Origin Dest  Distance TaxiIn TaxiOut Cancelled\n    ##    <chr>  <chr>    <int>  <int>   <int>     <int>\n    ##  1 IAH    DFW        224      7      13         0\n    ##  2 IAH    DFW        224      6       9         0\n    ##  3 IAH    DFW        224      5      17         0\n    ##  4 IAH    DFW        224      9      22         0\n    ##  5 IAH    DFW        224      9       9         0\n    ##  6 IAH    DFW        224      6      13         0\n    ##  7 IAH    DFW        224     12      15         0\n    ##  8 IAH    DFW        224      7      12         0\n    ##  9 IAH    DFW        224      8      22         0\n    ## 10 IAH    DFW        224      6      19         0\n    ## # ℹ 227,486 more rows\n    #ou\n    hflights1 |> select(Origin:Cancelled) \n    ## # A tibble: 227,496 × 6\n    ##    Origin Dest  Distance TaxiIn TaxiOut Cancelled\n    ##    <chr>  <chr>    <int>  <int>   <int>     <int>\n    ##  1 IAH    DFW        224      7      13         0\n    ##  2 IAH    DFW        224      6       9         0\n    ##  3 IAH    DFW        224      5      17         0\n    ##  4 IAH    DFW        224      9      22         0\n    ##  5 IAH    DFW        224      9       9         0\n    ##  6 IAH    DFW        224      6      13         0\n    ##  7 IAH    DFW        224     12      15         0\n    ##  8 IAH    DFW        224      7      12         0\n    ##  9 IAH    DFW        224      8      22         0\n    ## 10 IAH    DFW        224      6      19         0\n    ## # ℹ 227,486 more rows\n    ```\n    :::\n\n\n2.  Sélectionner les variables `DepTime`, `ArrTime`, `ActualElapsedTime`, `AirTime`, `ArrDelay` et `DepDelay`. On pourra remarquer que toutes ces variables contiennent les chaînes de caractère `Time` ou `Delay` et utiliser la *helper function* **contains()**.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    hflights1 |> select(contains(\"Time\"),contains(\"Delay\"))\n    ## # A tibble: 227,496 × 6\n    ##    DepTime ArrTime ActualElapsedTime AirTime ArrDelay DepDelay\n    ##      <int>   <int>             <int>   <int>    <int>    <int>\n    ##  1    1400    1500                60      40      -10        0\n    ##  2    1401    1501                60      45       -9        1\n    ##  3    1352    1502                70      48       -8       -8\n    ##  4    1403    1513                70      39        3        3\n    ##  5    1405    1507                62      44       -3        5\n    ##  6    1359    1503                64      45       -7       -1\n    ##  7    1359    1509                70      43       -1       -1\n    ##  8    1355    1454                59      40      -16       -5\n    ##  9    1443    1554                71      41       44       43\n    ## 10    1443    1553                70      45       43       43\n    ## # ℹ 227,486 more rows\n    #ou\n    hflights1 |> select(contains(c(\"Time\",\"Delay\")))\n    ## # A tibble: 227,496 × 6\n    ##    DepTime ArrTime ActualElapsedTime AirTime ArrDelay DepDelay\n    ##      <int>   <int>             <int>   <int>    <int>    <int>\n    ##  1    1400    1500                60      40      -10        0\n    ##  2    1401    1501                60      45       -9        1\n    ##  3    1352    1502                70      48       -8       -8\n    ##  4    1403    1513                70      39        3        3\n    ##  5    1405    1507                62      44       -3        5\n    ##  6    1359    1503                64      45       -7       -1\n    ##  7    1359    1509                70      43       -1       -1\n    ##  8    1355    1454                59      40      -16       -5\n    ##  9    1443    1554                71      41       44       43\n    ## 10    1443    1553                70      45       43       43\n    ## # ℹ 227,486 more rows\n    ```\n    :::\n\n\n3.  Ajouter une variable `ActualGroundTime` qui correspond à `ActualElapsedTime` moins `AirTime`.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    hflights2 <- hflights1 |> mutate(ActualGroundTime=ActualElapsedTime-AirTime)\n    head(hflights2)\n    ## # A tibble: 6 × 22\n    ##    Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum\n    ##   <int> <int>      <int>     <int>   <int>   <int> <chr>             <int>\n    ## 1  2011     1          1         6    1400    1500 American            428\n    ## 2  2011     1          2         7    1401    1501 American            428\n    ## 3  2011     1          3         1    1352    1502 American            428\n    ## 4  2011     1          4         2    1403    1513 American            428\n    ## 5  2011     1          5         3    1405    1507 American            428\n    ## 6  2011     1          6         4    1359    1503 American            428\n    ## # ℹ 14 more variables: TailNum <chr>, ActualElapsedTime <int>, AirTime <int>,\n    ## #   ArrDelay <int>, DepDelay <int>, Origin <chr>, Dest <chr>, Distance <int>,\n    ## #   TaxiIn <int>, TaxiOut <int>, Cancelled <int>, CancellationCode <chr>,\n    ## #   Diverted <int>, ActualGroundTime <int>\n    ```\n    :::\n\n\n4.  Ajouter la variable `AverageSpeed` (`=Distance/AirTime`) et ordonner la table selon les valeurs décroissantes de cette variable.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    hflights3 <- hflights2 |> \n      mutate(AverageSpeed=Distance/AirTime) |>\n      arrange(desc(AverageSpeed))\n    ```\n    :::\n\n\n5.  Sélectionner les vols à destination de `JFK`.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    filter(hflights3,Dest==\"JFK\")\n    ## # A tibble: 695 × 23\n    ##     Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum\n    ##    <int> <int>      <int>     <int>   <int>   <int> <chr>             <int>\n    ##  1  2011     2          7         1     659    1045 JetBlue             620\n    ##  2  2011     2          6         7     700    1045 JetBlue             620\n    ##  3  2011     2          5         6     700    1113 JetBlue             620\n    ##  4  2011     2          6         7    1529    1917 JetBlue             624\n    ##  5  2011     1         24         1     707    1059 JetBlue             620\n    ##  6  2011     1         24         1    1532    1923 JetBlue             624\n    ##  7  2011     2         12         6     659    1105 JetBlue             620\n    ##  8  2011    10         19         3     644    1043 JetBlue             620\n    ##  9  2011    11         10         4    1629    2027 JetBlue             622\n    ## 10  2011     2          8         2     654    1049 JetBlue             620\n    ## # ℹ 685 more rows\n    ## # ℹ 15 more variables: TailNum <chr>, ActualElapsedTime <int>, AirTime <int>,\n    ## #   ArrDelay <int>, DepDelay <int>, Origin <chr>, Dest <chr>, Distance <int>,\n    ## #   TaxiIn <int>, TaxiOut <int>, Cancelled <int>, CancellationCode <chr>,\n    ## #   Diverted <int>, ActualGroundTime <int>, AverageSpeed <dbl>\n    ```\n    :::\n\n\n6.  Calculer le nombre de vols à destination de `JFK`.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    hflights3 |> filter(Dest==\"JFK\") |> summarise(numb_to_JFK=n())\n    ## # A tibble: 1 × 1\n    ##   numb_to_JFK\n    ##         <int>\n    ## 1         695\n    ```\n    :::\n\n\n7.  Créer un résumé de `hflights1` qui contient :\n\n    -   `n_flights` : le nombre total de vols ;\n    -   `n_dest`: le nombre total de destinations ;\n    -   `n_carrier` : le nombre total de compagnies.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    hflights1 |> summarize(n_flights=n(),n_dest=n_distinct(Dest),n_carrier=n_distinct(UniqueCarrier))\n    ## # A tibble: 1 × 3\n    ##   n_flights n_dest n_carrier\n    ##       <int>  <int>     <int>\n    ## 1    227496    116        15\n    ```\n    :::\n\n\n8.  Créer un résumé de `hflights1` qui contient, pour les vols de la compagnie `American`,\n\n    -   le nombre total de vols ;\n    -   le nombre total de vols annulés ;\n    -   la valeur moyenne de `ArrDelay` (attention à la gestion des `NA`...).\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    hflights1 |> filter(UniqueCarrier==\"American\") |> \n      summarize(n_fligths_Am=n(),n_can_Am=sum(Cancelled),\n            mean_ArrDelay_am=mean(ArrDelay,na.rm=TRUE))\n    ## # A tibble: 1 × 3\n    ##   n_fligths_Am n_can_Am mean_ArrDelay_am\n    ##          <int>    <int>            <dbl>\n    ## 1         3244       60            0.892\n    ```\n    :::\n\n\n9.  Calculer pour chaque compagnie :\n\n    -   le nombre total de vols ;\n    -   La valeur moyenne de `AirTime`.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    hflights1 |> group_by(UniqueCarrier) |>\n      summarise(n_flights=n(),mean_AirTime=mean(AirTime,na.rm=TRUE))\n    ## # A tibble: 15 × 3\n    ##    UniqueCarrier      n_flights mean_AirTime\n    ##    <chr>                  <int>        <dbl>\n    ##  1 AirTran                 2139         92.7\n    ##  2 Alaska                   365        254. \n    ##  3 American                3244         69.7\n    ##  4 American_Eagle          4648         93.8\n    ##  5 Atlantic_Southeast      2204        104. \n    ##  6 Continental            70032        145. \n    ##  7 Delta                   2641         97.8\n    ##  8 ExpressJet             73053         83.2\n    ##  9 Frontier                 838        125. \n    ## 10 JetBlue                  695        184. \n    ## 11 Mesa                      79        122. \n    ## 12 SkyWest                16061        113. \n    ## 13 Southwest              45343         86.7\n    ## 14 US_Airways              4082        134. \n    ## 15 United                  2072        157.\n    ```\n    :::\n\n\n10. Ordonner les compagnies en fonction des retards moyens au départ.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    hflights1 |> \n      group_by(UniqueCarrier) |>\n      filter(!is.na(DepDelay) & DepDelay>0) |>\n      summarise(meanDepDelay = mean(DepDelay)) |>\n      arrange(meanDepDelay)\n    ## # A tibble: 15 × 2\n    ##    UniqueCarrier      meanDepDelay\n    ##    <chr>                     <dbl>\n    ##  1 Continental                17.9\n    ##  2 Alaska                     20.8\n    ##  3 Southwest                  21.9\n    ##  4 Frontier                   22.7\n    ##  5 Mesa                       24.5\n    ##  6 SkyWest                    24.6\n    ##  7 American                   24.7\n    ##  8 US_Airways                 26.5\n    ##  9 ExpressJet                 26.9\n    ## 10 United                     28.8\n    ## 11 Delta                      32.4\n    ## 12 AirTran                    33.4\n    ## 13 American_Eagle             37.9\n    ## 14 JetBlue                    43.5\n    ## 15 Atlantic_Southeast         49.3\n    ```\n    :::\n\n:::\n\n::: {#exr-exo-dplyr-tennis name=\"Tournois du grand chelem au tennis\"}\nOn considère le données sur les résultats de tennis dans les tournois du grand chelem en 2013. Les données, ainsi que le descriptif des variables, se trouvent à l'adresse <https://archive.ics.uci.edu/ml/datasets/Tennis+Major+Tournament+Match+Statistics>.\n\nOn s'intéresse d'abord au tournoi masculin de Roland Garros. On répondra aux questions à l'aide des verbes **dplyr**.\n\n1.  Importer les données.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    FrenchOpen_men_2013 <- read_csv(\"data/FrenchOpen-men-2013.csv\")\n    RG2013 <- FrenchOpen_men_2013\n    RG2013\n    ## # A tibble: 125 × 42\n    ##    Player1  Player2 Round Result FNL.1 FNL.2 FSP.1 FSW.1 SSP.1 SSW.1 ACE.1 DBF.1\n    ##    <chr>    <chr>   <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n    ##  1 Pablo C… Roger …     1      0     0     3    62    27    38    11     1     3\n    ##  2 Somdev … Daniel…     1      1     3     0    62    54    38    22     7     3\n    ##  3 Tobias … Paolo …     1      1     3     2    62    53    38    15     4     6\n    ##  4 Julien … Ricard…     1      1     3     1    72    87    28    19    14     2\n    ##  5 Lukas L… Sam Qu…     1      0     0     3    52    31    48    22     4     4\n    ##  6 Jan Haj… Denis …     1      1     3     1    70    58    30    18     4     4\n    ##  7 Adrian … Pablo …     1      0     2     3    63    71    37    38     5     5\n    ##  8 Gilles … Lleyto…     1      1     3     2    59    42    41    25     7     2\n    ##  9 Philipp… Marin …     1      0     0     3    56    27    44    13     0     6\n    ## 10 Radek S… Nick K…     1      0     0     3    63    62    37    29     5     4\n    ## # ℹ 115 more rows\n    ## # ℹ 30 more variables: WNR.1 <dbl>, UFE.1 <dbl>, BPC.1 <dbl>, BPW.1 <dbl>,\n    ## #   NPA.1 <dbl>, NPW.1 <dbl>, TPW.1 <dbl>, ST1.1 <dbl>, ST2.1 <dbl>,\n    ## #   ST3.1 <dbl>, ST4.1 <dbl>, ST5.1 <dbl>, FSP.2 <dbl>, FSW.2 <dbl>,\n    ## #   SSP.2 <dbl>, SSW.2 <dbl>, ACE.2 <dbl>, DBF.2 <dbl>, WNR.2 <dbl>,\n    ## #   UFE.2 <dbl>, BPC.2 <dbl>, BPW.2 <dbl>, NPA.2 <dbl>, NPW.2 <dbl>,\n    ## #   TPW.2 <dbl>, ST1.2 <dbl>, ST2.2 <dbl>, ST3.2 <dbl>, ST4.2 <dbl>, …\n    ```\n    :::\n\n\n2.  Afficher le nom des adversaires de `Roger Federer`.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    RG2013 |> filter(Player1==\"Roger Federer\" | Player2==\"Roger Federer\") |>\n      select(Player1,Player2)\n    ## # A tibble: 5 × 2\n    ##   Player1             Player2      \n    ##   <chr>               <chr>        \n    ## 1 Pablo Carreno-Busta Roger Federer\n    ## 2 Somdev Devvarman    Roger Federer\n    ## 3 Julien Benneteau    Roger Federer\n    ## 4 Gilles Simon        Roger Federer\n    ## 5 Jo-Wilfried Tsonga  Roger Federer\n    ```\n    :::\n\n\n3.  Afficher le nom des demi-finalistes (ceux qui ont atteint le 6ème tour).\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    RG2013 |> filter(Round==6) |> select(Player1,Player2)\n    ## # A tibble: 2 × 2\n    ##   Player1        Player2           \n    ##   <chr>          <chr>             \n    ## 1 David Ferrer   Jo-Wilfried Tsonga\n    ## 2 Novak Djokovic Rafael Nadal\n    ```\n    :::\n\n\n4.  Combien y a t-il eu de points disputés en moyenne par match ? Il faudra penser à ajouter dans la table une variable correspondant au nombre de points de chaque match (verbe `mutate`).\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    RG2013 |> mutate(nb_points=TPW.1+TPW.2) |> select(nb_points) |> summarize_all(mean)\n    ## # A tibble: 1 × 1\n    ##   nb_points\n    ##       <dbl>\n    ## 1      219.\n    ```\n    :::\n\n\n5.  Combien y a t-il eu d'aces par match en moyenne ?\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    RG2013 |> mutate(nb_aces=ACE.1+ACE.2) |> summarize(mean_aces=mean(nb_aces))\n    ## # A tibble: 1 × 1\n    ##   mean_aces\n    ##       <dbl>\n    ## 1      12.7\n    ```\n    :::\n\n\n6.  Combien y a t-il eu d'aces par match en moyenne à chaque tour ?\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    RG2013 |> group_by(Round) |> mutate(nb_aces=ACE.1+ACE.2) |>\n      summarize(mean_aces=mean(nb_aces))\n    ## # A tibble: 7 × 2\n    ##   Round mean_aces\n    ##   <dbl>     <dbl>\n    ## 1     1     13.5 \n    ## 2     2     13.2 \n    ## 3     3     12.6 \n    ## 4     4      9.12\n    ## 5     5      7   \n    ## 6     6     10   \n    ## 7     7      6\n    ```\n    :::\n\n\n7.  Combien y a t-il eu de doubles fautes au total dans le tournoi (attention aux données manquantes, taper **help(sum)** pour voir comment les gérer) ?\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    RG2013 |> mutate(nb_df=DBF.1+DBF.2) |> \n      summarize(nb_dbfaults=sum(nb_df,na.rm=TRUE))\n    ## # A tibble: 1 × 1\n    ##   nb_dbfaults\n    ##         <dbl>\n    ## 1         812\n    ```\n    :::\n\n\n8.  Importer les données pour le tournoi masculin de Wimbledon 2013.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    WIMB2013 <- read_csv(\"data/Wimbledon-men-2013.csv\")\n    WIMB2013\n    ## # A tibble: 114 × 42\n    ##    Player1  Player2 Round Result FNL.1 FNL.2 FSP.1 FSW.1 SSP.1 SSW.1 ACE.1 DBF.1\n    ##    <chr>    <chr>   <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n    ##  1 B.Becker A.Murr…     1      0     0     3    59    29    41    14     5     1\n    ##  2 J.Ward   Y-H.Lu      1      0     1     3    62    77    38    35    18     4\n    ##  3 N.Mahut  J.Hajek     1      1     3     0    72    44    28    10    17     3\n    ##  4 T.Robre… A.Bogo…     1      1     3     0    77    40    23    12     6     0\n    ##  5 R.Haase  M.Youz…     1      0     0     3    68    61    32    15     7     2\n    ##  6 M.Gicqu… V.Posp…     1      0     0     3    59    41    41    27     7     6\n    ##  7 A.Kuzne… A.Mont…     1      1     3     1    63    56    37    21    21     3\n    ##  8 J.Tipsa… V.Troi…     1      0     0     3    61    47    39    21     3     1\n    ##  9 M.Baghd… M.Cilic     1      0     0     3    61    31    39    16     4     5\n    ## 10 K.De Sc… P.Lore…     1      1     3     0    67    56    33    21    22     6\n    ## # ℹ 104 more rows\n    ## # ℹ 30 more variables: WNR.1 <dbl>, UFE.1 <dbl>, BPC.1 <dbl>, BPW.1 <dbl>,\n    ## #   NPA.1 <dbl>, NPW.1 <dbl>, TPW.1 <lgl>, ST1.1 <dbl>, ST2.1 <dbl>,\n    ## #   ST3.1 <dbl>, ST4.1 <dbl>, ST5.1 <dbl>, FSP.2 <dbl>, FSW.2 <dbl>,\n    ## #   SSP.2 <dbl>, SSW.2 <dbl>, ACE.2 <dbl>, DBF.2 <dbl>, WNR.2 <dbl>,\n    ## #   UFE.2 <dbl>, BPC.2 <dbl>, BPW.2 <dbl>, NPA.2 <dbl>, NPW.2 <dbl>,\n    ## #   TPW.2 <lgl>, ST1.2 <dbl>, ST2.2 <dbl>, ST3.2 <dbl>, ST4.2 <dbl>, …\n    ```\n    :::\n\n\n9.  Concaténer les tables en ajoutant une variable permettant d'identifier le tournoi. On pourra utiliser **bind_rows** abev l'option **.id**.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    RG_WIMB2013 <- bind_rows(\"RG\"=RG2013,\"WIMB\"=WIMB2013,.id=\"Tournament\")\n    ```\n    :::\n\n\n10. Afficher les matchs de Federer pour chaque tournoi.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    RG_WIMB2013  |> filter(Player1==\"Roger Federer\" | \n                          Player2==\"Roger Federer\" |\n                          Player1==\"R.Federer\" | \n                          Player2==\"R.Federer\") \n    ## # A tibble: 7 × 43\n    ##   Tournament Player1    Player2 Round Result FNL.1 FNL.2 FSP.1 FSW.1 SSP.1 SSW.1\n    ##   <chr>      <chr>      <chr>   <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n    ## 1 RG         Pablo Car… Roger …     1      0     0     3    62    27    38    11\n    ## 2 RG         Somdev De… Roger …     2      0     0     3    61    19    39    16\n    ## 3 RG         Julien Be… Roger …     3      0     0     3    82    41    18     8\n    ## 4 RG         Gilles Si… Roger …     4      0     2     3    61    65    39    28\n    ## 5 RG         Jo-Wilfri… Roger …     5      1     3     0    75    46    25    10\n    ## 6 WIMB       V.Hanescu  R.Fede…     1      0     0     3    85    26    15     3\n    ## 7 WIMB       S.Stakhov… R.Fede…     2      1     3     1    66    83    34    36\n    ## # ℹ 32 more variables: ACE.1 <dbl>, DBF.1 <dbl>, WNR.1 <dbl>, UFE.1 <dbl>,\n    ## #   BPC.1 <dbl>, BPW.1 <dbl>, NPA.1 <dbl>, NPW.1 <dbl>, TPW.1 <dbl>,\n    ## #   ST1.1 <dbl>, ST2.1 <dbl>, ST3.1 <dbl>, ST4.1 <dbl>, ST5.1 <dbl>,\n    ## #   FSP.2 <dbl>, FSW.2 <dbl>, SSP.2 <dbl>, SSW.2 <dbl>, ACE.2 <dbl>,\n    ## #   DBF.2 <dbl>, WNR.2 <dbl>, UFE.2 <dbl>, BPC.2 <dbl>, BPW.2 <dbl>,\n    ## #   NPA.2 <dbl>, NPW.2 <dbl>, TPW.2 <dbl>, ST1.2 <dbl>, ST2.2 <dbl>,\n    ## #   ST3.2 <dbl>, ST4.2 <dbl>, ST5.2 <dbl>\n    ```\n    :::\n\n\n    ou\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    RG_WIMB2013  |> filter(grepl(\"Federer\",Player2) | grepl(\"Federer\",Player2))\n    ## # A tibble: 7 × 43\n    ##   Tournament Player1    Player2 Round Result FNL.1 FNL.2 FSP.1 FSW.1 SSP.1 SSW.1\n    ##   <chr>      <chr>      <chr>   <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n    ## 1 RG         Pablo Car… Roger …     1      0     0     3    62    27    38    11\n    ## 2 RG         Somdev De… Roger …     2      0     0     3    61    19    39    16\n    ## 3 RG         Julien Be… Roger …     3      0     0     3    82    41    18     8\n    ## 4 RG         Gilles Si… Roger …     4      0     2     3    61    65    39    28\n    ## 5 RG         Jo-Wilfri… Roger …     5      1     3     0    75    46    25    10\n    ## 6 WIMB       V.Hanescu  R.Fede…     1      0     0     3    85    26    15     3\n    ## 7 WIMB       S.Stakhov… R.Fede…     2      1     3     1    66    83    34    36\n    ## # ℹ 32 more variables: ACE.1 <dbl>, DBF.1 <dbl>, WNR.1 <dbl>, UFE.1 <dbl>,\n    ## #   BPC.1 <dbl>, BPW.1 <dbl>, NPA.1 <dbl>, NPW.1 <dbl>, TPW.1 <dbl>,\n    ## #   ST1.1 <dbl>, ST2.1 <dbl>, ST3.1 <dbl>, ST4.1 <dbl>, ST5.1 <dbl>,\n    ## #   FSP.2 <dbl>, FSW.2 <dbl>, SSP.2 <dbl>, SSW.2 <dbl>, ACE.2 <dbl>,\n    ## #   DBF.2 <dbl>, WNR.2 <dbl>, UFE.2 <dbl>, BPC.2 <dbl>, BPW.2 <dbl>,\n    ## #   NPA.2 <dbl>, NPW.2 <dbl>, TPW.2 <dbl>, ST1.2 <dbl>, ST2.2 <dbl>,\n    ## #   ST3.2 <dbl>, ST4.2 <dbl>, ST5.2 <dbl>\n    ```\n    :::\n\n\n11. Comparer les nombres d'aces par matchs à chaque tour pour les tournois de Roland Garros et Wimbledon.\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    RG_WIMB2013 |> group_by(Tournament,Round) |> \n      mutate(nb_aces=ACE.1+ACE.2) |> summarize(mean_ace=mean(nb_aces))\n    ## # A tibble: 14 × 3\n    ## # Groups:   Tournament [2]\n    ##    Tournament Round mean_ace\n    ##    <chr>      <dbl>    <dbl>\n    ##  1 RG             1    13.5 \n    ##  2 RG             2    13.2 \n    ##  3 RG             3    12.6 \n    ##  4 RG             4     9.12\n    ##  5 RG             5     7   \n    ##  6 RG             6    10   \n    ##  7 RG             7     6   \n    ##  8 WIMB           1    21.1 \n    ##  9 WIMB           2    23.9 \n    ## 10 WIMB           3    24   \n    ## 11 WIMB           4    24.4 \n    ## 12 WIMB           5    26.5 \n    ## 13 WIMB           6    27.5 \n    ## 14 WIMB           7    13\n    ```\n    :::\n\n\n    ou pour une présentation plus synthétique\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    RG_WIMB2013 |> group_by(Tournament,Round) |> \n      mutate(nb_aces=ACE.1+ACE.2) |> \n      summarize(mean_ace=mean(nb_aces)) |>\n      pivot_wider(names_from = \"Round\",values_from = \"mean_ace\")\n    ## # A tibble: 2 × 8\n    ## # Groups:   Tournament [2]\n    ##   Tournament   `1`   `2`   `3`   `4`   `5`   `6`   `7`\n    ##   <chr>      <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n    ## 1 RG          13.5  13.2  12.6  9.12   7    10       6\n    ## 2 WIMB        21.1  23.9  24   24.4   26.5  27.5    13\n    ```\n    :::\n\n:::\n\n### Compléments : Tidy data avec tidyr\n\nL'utilisation de **dplyr** et de **ggplot** (que nous verrons dans la partie suivante) suppose que les données sont présentées sous un format adéquat : une ligne est un individu et une colonne une variable, on parle alors de **tidy data**. Cette représentation peut dépendre du contexte, et surtout de ce que l'on souhaite faire avec les données. Considérons par exemple le tableau suivant qui présente les taux de chômage des départements français en 2002, 2006, 2011\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read_delim(\"data/tauxchomage.csv\",delim=\";\") |> select(-1)\ndf\n## # A tibble: 96 × 4\n##    NOM_DPT                 TCHOMB1T01 TCHOMB1T06 TCHOMB1T11\n##    <chr>                        <dbl>      <dbl>      <dbl>\n##  1 Ain                            3.9        5.9        6.6\n##  2 Aisne                         10.6       12         13.2\n##  3 Allier                         9          9.2        9.7\n##  4 Alpes-de-Haute-Provence        9.5        9.7       10.3\n##  5 Hautes-Alpes                   7.1        7.7        8.3\n##  6 Alpes-Maritimes                9.1        8.9        9.2\n##  7 Ardèche                        8.1        9.6        9.7\n##  8 Ardennes                      11.5       12.8       10.9\n##  9 Ariège                         9.2       10.1       10.6\n## 10 Aube                           8.2       10         10  \n## # ℹ 86 more rows\n```\n:::\n\n\nPrésenté ainsi ce tableau comporte 4 variables (en comptant l'identifiant du département). Dans certaines situations, on peut préférer une structure à 3 variables :\n\n-   le département\n-   l'année\n-   le taux de chômage\n\nNous verrons qu'il n'est par exemple pas possible de faire un **boxplot** permettant de visualiser la distribution du taux de chômage en fonction de l'année à l'aide de **ggplot2**. Pour passer à ce format il est nécessaire d'assembler les 3 colonnes correspondant aux taux de chômage en une seule colonne et ajouter une colonne qui permette d'identifier l'année. La table obtenue aura plus de lignes, on parle de **format long**. La fonction **pivot_longer** du package **tidyr** permet de faire cette transformation :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- df |> pivot_longer(-NOM_DPT,names_to=\"Année\",values_to=\"TCHOM\") |> \n  mutate(Année=fct_recode(Année,\"2001\"=\"TCHOMB1T01\",\"2006\"=\"TCHOMB1T06\",\"2011\"=\"TCHOMB1T11\"))\ndf1\n## # A tibble: 288 × 3\n##    NOM_DPT                 Année TCHOM\n##    <chr>                   <fct> <dbl>\n##  1 Ain                     2001    3.9\n##  2 Ain                     2006    5.9\n##  3 Ain                     2011    6.6\n##  4 Aisne                   2001   10.6\n##  5 Aisne                   2006   12  \n##  6 Aisne                   2011   13.2\n##  7 Allier                  2001    9  \n##  8 Allier                  2006    9.2\n##  9 Allier                  2011    9.7\n## 10 Alpes-de-Haute-Provence 2001    9.5\n## # ℹ 278 more rows\n```\n:::\n\n\nIl sera alors aisé de faire le boxplot souhaité avec\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df1)+aes(x=Année,y=TCHOM)+geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](03-dplyr_files/figure-html/unnamed-chunk-81-1.png){width=672}\n:::\n:::\n\n\nL'opération inverse peut être effectuée avec **pivot_wider** :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 |> pivot_wider(names_from=\"Année\",values_from=\"TCHOM\")\n## # A tibble: 96 × 4\n##    NOM_DPT                 `2001` `2006` `2011`\n##    <chr>                    <dbl>  <dbl>  <dbl>\n##  1 Ain                        3.9    5.9    6.6\n##  2 Aisne                     10.6   12     13.2\n##  3 Allier                     9      9.2    9.7\n##  4 Alpes-de-Haute-Provence    9.5    9.7   10.3\n##  5 Hautes-Alpes               7.1    7.7    8.3\n##  6 Alpes-Maritimes            9.1    8.9    9.2\n##  7 Ardèche                    8.1    9.6    9.7\n##  8 Ardennes                  11.5   12.8   10.9\n##  9 Ariège                     9.2   10.1   10.6\n## 10 Aube                       8.2   10     10  \n## # ℹ 86 more rows\n```\n:::\n\n\nLe package **tidyr** possède plusieurs autres verbes qui pourront aider l'utilisateur à mettre la table sous le meilleur format pour les analyses. Citons par exemple le verbe **separate** qui va séparer une colonne en plusieurs :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(df <- tibble(date=as.Date(c(\"01/03/2015\",\"05/18/2017\",\n                             \"09/14/2018\"),\"%m/%d/%Y\"),\n              temp=c(18,21,15)))\n## # A tibble: 3 × 2\n##   date        temp\n##   <date>     <dbl>\n## 1 2015-01-03    18\n## 2 2017-05-18    21\n## 3 2018-09-14    15\n (df1 <- df |> separate_wider_delim(date,delim=\"-\",\n                                       names=c(\"year\",\"month\",\"day\")))\n## # A tibble: 3 × 4\n##   year  month day    temp\n##   <chr> <chr> <chr> <dbl>\n## 1 2015  01    03       18\n## 2 2017  05    18       21\n## 3 2018  09    14       15\n```\n:::\n\n\nou le verbe **unite** qui fera l'opération inverse\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 |> \n  unite(date,year,month,day,sep=\"/\") |>\n  mutate(date1=lubridate::as_date(date))\n## # A tibble: 3 × 3\n##   date        temp date1     \n##   <chr>      <dbl> <date>    \n## 1 2015/01/03    18 2015-01-03\n## 2 2017/05/18    21 2017-05-18\n## 3 2018/09/14    15 2018-09-14\n```\n:::\n\n\nCitons enfin les verbes :\n\n-   **separate_longer_delim** qui permettra de séparer des informations en plusieurs lignes ;\n-   **separate_wider_regex** pour créer de nouvelles colonnes ;\n-   **complete** pour ajouter des lignes dans un tableau, par exemple des non réponses à un questionnaire.\n",
    "supporting": [
      "03-dplyr_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}