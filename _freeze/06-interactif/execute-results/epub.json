{
  "hash": "2c167915879c058d530218b1649d3fab",
  "result": {
    "markdown": "\n::: {.content-visible when-format=\"html\"}\n::: {.cell}\n\\newcommand{\\prob}{\\mathbf P}\n\\newcommand{\\lt}{<}\n\\newcommand{\\mt}{>}\n:::\n\n```{=html}\n<style>\ndiv.correction {\n  color: black;\n  background-color: #F0F0F0;\n  font-style: normal;\n  /*display: none;*/\n}\n\n.corR {\n  font-style: italic;\n  /*display: none;*/\n}\n</style>\n```\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\\solntrue\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n# Quelques outils de visualisation dynamique/interactive\n\nTout comme **leaflet** pour les cartes, il existe de nombreux outils **R** dédiés à la visualisation interactive. Nous en présentons quelques uns dans cette partie.\n\n## Représentations classiques avec `rAmCharts` et `plotly`\n\nLe package [rAmCharts](https://datastorm-open.github.io/introduction_ramcharts/) est très utile pour donner un caractère interactif à des représentations graphiques standards (nuages de points, séries temporelles, histogrammes...). Ce package a été fait dans l'esprit d'utiliser les fonctions graphiques de **R** en utilisant le préfixe **am**. La syntaxe est très proche de celle des fonctions graphiques standards. On a par exemple :\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rAmCharts)\namHist(iris$Petal.Length)\n```\n\n::: {.cell-output-display}\n![](06-interactif_files/figure-epub/unnamed-chunk-2-1.png)\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\namPlot(iris, col = colnames(iris)[1:2], type = c(\"l\", \"st\"), \n       zoom = TRUE, legend = TRUE)\n```\n\n::: {.cell-output-display}\n![](06-interactif_files/figure-epub/unnamed-chunk-3-1.png)\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\namBoxplot(iris)\n```\n\n::: {.cell-output-display}\n![](06-interactif_files/figure-epub/unnamed-chunk-4-1.png)\n:::\n:::\n\n\n\n\n[plotly](https://plot.ly/r/) permet de faire des choses semblables avec avec une syntaxe spécifique. Les commandes **plotly** se décomposent essentiellement en 3 parties :\n\n-   le type de représentation graphique (**plot_ly**}) ;\n-   les ajouts que l'on souhaite effectuer (**add_trace**) ;\n-   la gestion de la fenêtre graphique (axes, titres...) (**layout**).\n\nOn trouvera un descriptif complet de ces 3 composantes [ici](https://plot.ly/r/reference/). On propose de tracer un nuage de points en dimension 2 et d'y ajouter la droite de régression. On commence par générer le nuage et ajuster le modèle linéaire :\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plotly)\nn <- 100\nX <- runif(n,-5,5)\nY <- 2+3*X+rnorm(n,0,1)\nD <- data.frame(X,Y)\nmodel <- lm(Y~X,data=D)\n```\n:::\n\n\n\n\nOn effectue maintenant le tracé\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nD |> plot_ly(x=~X,y=~Y) |>\n  add_markers(type=\"scatter\",mode=\"markers\",\n              marker=list(color=\"red\"),name=\"Nuage\") |>\n  add_trace(y=fitted(model),type=\"scatter\",mode='lines',\n            name=\"Régression\",line=list(color=\"blue\")) |> \n  layout(title=\"Régression\",xaxis=list(title=\"abscisse\"),\n         yaxis=list(title=\"ordonnées\"))\n```\n\n::: {.cell-output-display}\n![](06-interactif_files/figure-epub/unnamed-chunk-6-1.png)\n:::\n:::\n\n\n\n\nContrairement à **ggplot**, **plotly** permet de faire de la 3D. Par exemple\n\n::: {.content-visible when-format=\"html\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_ly(z = volcano, type = \"surface\")\nplot_ly(z = volcano, type = \"contour\")\n```\n:::\n\n\n\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_ly(z = volcano, type = \"surface\")\n```\n:::\n\n\n\n\n![](surface-plot.pdf)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_ly(z = volcano, type = \"contour\")\n```\n\n::: {.cell-output-display}\n![](06-interactif_files/figure-epub/unnamed-chunk-10-1.png)\n:::\n:::\n\n\n\n:::\n\n\n\n\n````{=html}\n<!--#\n\n::: {.cell name='plotly_html'}\n\n```{.r .cell-code}\nplot_ly(z = volcano, type = \"surface\")\n```\n\n::: {.cell-output-display}\n![](06-interactif_files/figure-epub/unnamed-chunk-11-1.png)\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_ly(z = volcano, type = \"contour\")\n```\n\n::: {.cell-output-display}\n![](06-interactif_files/figure-epub/unnamed-chunk-12-1.png)\n:::\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell name='plotly_pdf'}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell name='plotly_pdf1'}\n\n:::\n\n\n\n-->\n````\n\nIl est possible de convertir des graphes **ggplot** au format **plotly** avec la fonction `ggplotly` :\n\n::: {.cell}\n\n```{.r .cell-code}\np <- ggplot(iris)+aes(x=Species,y=Sepal.Length)+geom_boxplot()+theme_classic()\nggplotly(p)\n```\n\n::: {.cell-output-display}\n![](06-interactif_files/figure-epub/unnamed-chunk-17-1.png)\n:::\n:::\n\n::: {#exr-exo-amchart-plotly name=\"Graphes basiques avec `rAmCharts` et `plotly`\"}\nPour le jeu de données **iris** on effectuera les graphes suivants en `rAmCharts` et `plotly`.\n\n1.  Nuage de points représentant les longueurs et largeurs de Sépales. On utilisera une couleur différente en fonction de l'espèce.\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    amPlot(Sepal.Length~Sepal.Width,data=iris,col=iris$Species) \n    ```\n    \n    ::: {.cell-output-display}\n    ![](06-interactif_files/figure-epub/unnamed-chunk-18-1.png)\n    :::\n    :::\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    iris |> plot_ly(x=~Sepal.Width,y=~Sepal.Length,color=~Species) |>\n      add_markers(type=\"scatter\",mode=\"markers\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](06-interactif_files/figure-epub/unnamed-chunk-19-1.png)\n    :::\n    :::\n\n2.  Boxplot permettant de visualiser la distribution de la variable `Petal.Length` en fonction de l'espèce.\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    amBoxplot(Petal.Length~Species,data=iris)\n    ```\n    \n    ::: {.cell-output-display}\n    ![](06-interactif_files/figure-epub/unnamed-chunk-20-1.png)\n    :::\n    :::\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    iris |> plot_ly(x=~Species,y=~Petal.Length) |> add_boxplot()\n    ```\n    \n    ::: {.cell-output-display}\n    ![](06-interactif_files/figure-epub/unnamed-chunk-21-1.png)\n    :::\n    :::\n:::\n\n## Graphes pour visualiser des réseaux avec visNetwork\n\nDe nombreuses données peuvent être visualisées à l'aide d'un graphe, notamment lorsqu'il s'agit de représenter des connexions entre individus. Un individu est alors représentés par un noeud et les individus connectés sont reliés par des arêtes. Le package [igraph](http://kateto.net/networks-r-igraph) propose une visualisation statique d'un réseau. Pour donner un caractère dynamique à ce type de représentation, on pourra utiliser le package [visNetwork](https://datastorm-open.github.io/visNetwork/interaction.html). Une représentation standard **visNetwork** s'effectue en spécifiant les nœuds et connexions d'un graphe, par exemple :\n\n::: {.cell}\n\n```{.r .cell-code}\nnodes <- data.frame(id = 1:15, label = paste(\"Id\", 1:15),\n                    group=sample(LETTERS[1:3], 15, replace = TRUE))\nedges <- data.frame(from = trunc(runif(15)*(15-1))+1,to = trunc(runif(15)*(15-1))+1)\nlibrary(visNetwork)\nvisNetwork(nodes,edges)\n```\n\n::: {.cell-output-display}\n![](06-interactif_files/figure-epub/unnamed-chunk-22-1.png)\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvisNetwork(nodes, edges) |> visOptions(highlightNearest = TRUE)\n```\n\n::: {.cell-output-display}\n![](06-interactif_files/figure-epub/unnamed-chunk-23-1.png)\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvisNetwork(nodes, edges) |> visOptions(highlightNearest = TRUE,\n                                        nodesIdSelection = TRUE)\n```\n\n::: {.cell-output-display}\n![](06-interactif_files/figure-epub/unnamed-chunk-24-1.png)\n:::\n:::\n\n\\\n\n::: {.cell}\n\n```{.r .cell-code}\nvisNetwork(nodes, edges) |> visOptions(selectedBy = \"group\")\n```\n\n::: {.cell-output-display}\n![](06-interactif_files/figure-epub/unnamed-chunk-25-1.png)\n:::\n:::\n\n::: {#exr-graphe name=\"Interactions entre media\"}\nOn considère un graphe qui représente des liens entre différents médias. Les données sont présentées [ici](http://www.kateto.net/polnet2018) et on peut les importer avec\n\n::: {.cell}\n\n```{.r .cell-code}\nnodes <- read.csv(\"data/Dataset1-Media-Example-NODES.csv\", header=T, as.is=T)\nlinks <- read.csv(\"data/Dataset1-Media-Example-EDGES.csv\", header=T, as.is=T)\nhead(nodes)\n##    id               media media.type type.label audience.size\n## 1 s01            NY Times          1  Newspaper            20\n## 2 s02     Washington Post          1  Newspaper            25\n## 3 s03 Wall Street Journal          1  Newspaper            30\n## 4 s04           USA Today          1  Newspaper            32\n## 5 s05            LA Times          1  Newspaper            20\n## 6 s06       New York Post          1  Newspaper            50\nhead(links)\n##   from  to weight      type\n## 1  s01 s02     10 hyperlink\n## 2  s01 s02     12 hyperlink\n## 3  s01 s03     22 hyperlink\n## 4  s01 s04     21 hyperlink\n## 5  s04 s11     22   mention\n## 6  s05 s15     21   mention\n```\n:::\n\nL'objet `nodes` représente les noeuds du graphe et l'objets `links` les arêtes. On définit l'objet `graphe` avec\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\nmedia <- graph_from_data_frame(d=links, vertices=nodes, directed=T) \nV(media)$name <- nodes$media\n```\n:::\n\net on peut le visualiser en faisant un `plot` de cet objet\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(media)\n```\n\n::: {.cell-output-display}\n![](06-interactif_files/figure-epub/unnamed-chunk-28-1.png)\n:::\n:::\n\n1.  Visualiser ce graphe avec **VisNetwork**. On pourra utiliser la fonction **toVisNetworkData**.\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    media.VN <- toVisNetworkData(media)\n    visNetwork(nodes=media.VN$nodes,edges=media.VN$edges)\n    ```\n    \n    ::: {.cell-output-display}\n    ![](06-interactif_files/figure-epub/unnamed-chunk-29-1.png)\n    :::\n    :::\n\n2.  Ajouter une option qui permette de sélectionner le type de media (Newspaper, TV ou Online).\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    names(media.VN$nodes)[4] <- \"labels\"\n    visNetwork(nodes=media.VN$nodes,edges=media.VN$edges) |> \n      visOptions(selectedBy = \"labels\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](06-interactif_files/figure-epub/unnamed-chunk-30-1.png)\n    :::\n    :::\n\n    \\\n\n3.  Utiliser une couleur différente pour chaque type de media.\n\n    ::: {.corR data-latex=\"\"}\n    Il suffit de donner le nom `group` à la variable **type.label**.\n    :::\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    media.VN1 <- media.VN\n    names(media.VN1$nodes)[3] <- \"group\"\n    visNetwork(nodes=media.VN1$nodes,edges=media.VN1$edges) |> \n      visOptions(selectedBy = \"labels\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](06-interactif_files/figure-epub/unnamed-chunk-31-1.png)\n    :::\n    :::\n\n    \\\n\n4.  Faire des flèches d'épaisseur différente en fonction du poids (weight). On pourra également ajouter l'option **visOptions(highlightNearest = TRUE)**.\n\n    ::: {.corR data-latex=\"\"}\n    Il suffit de donner le nom **value** à la variable weight.\n    :::\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    names(media.VN1$edges)[3] <- \"value\"\n    visNetwork(nodes=media.VN1$nodes,edges=media.VN1$edges) |> \n      visOptions(selectedBy = \"labels\",highlightNearest = TRUE) \n    ```\n    \n    ::: {.cell-output-display}\n    ![](06-interactif_files/figure-epub/unnamed-chunk-32-1.png)\n    :::\n    :::\n:::\n\n## Dashboard\n\nUn tableau de bord permet de visualiser \"facilement\" et \"rapidement\" divers graphes et/ou résumés statistiques en lien avec une problématique donnée. Sur **R** le package `flexdashboard` permet de construire de tels tableaux de bord. On trouvera un descriptif précis de ce package à cette url : <https://rmarkdown.rstudio.com/flexdashboard/>. On utilisera cette documentation pour faire l'exercice suivant.\n\n::: {#exr-dash-ozone name=\"Dashboard pour modèles linéaires\"}\nOn considère le jeu de données `ozone.txt`. Le problème est d'expliquer la concentration maximale en ozone quotidienne (variable `maxO3`) par d'autres variables météorologiques (températures et indicateurs de nébulosité relevés à différents moments de la journée...). On souhaite faire un tableau de bord qui permettra de :\n\n-   visualiser les données : la base de données ainsi qu'un ou deux graphes descriptifs sur la variable à expliquer ;\n\n-   visualiser les modèles linéaires simples : on choisit une variable explicative et on visualise le graphe de la régression ainsi que le modèle ;\n\n-   visualiser le modèle linéaire complet : on affiche le résultat de la régression avec toutes les variables et on représente le graphe des résidus ;\n\n-   choisir les variables explicatives.\n\n1.  Avant de réaliser le dashboard, on propose d'écrire quelques commandes pour calculer les différentes sorties :\n\n    a.  On considère uniquement les variables quantitatives du jeu de données. Visualiser les corrélations entre ces variables à l'aide de la fonction `corrplot` du package `corrplot`.\n\n        ::: {.cell}\n        \n        :::\n\n        ::: {.cell teacher='true'}\n        \n        ```{.r .cell-code}\n        df <- read.table(\"data/ozone.txt\")\n        cc <- cor(df[,1:11])\n        mat.cor <- corrplot::corrplot(cc)\n        ```\n        \n        ::: {.cell-output-display}\n        ![](06-interactif_files/figure-epub/unnamed-chunk-34-1.png)\n        :::\n        :::\n\n    b.  Représenter l'histogramme de la variable **maxO3**, on fera le graphe avec `ggplot`, `rAmCharts` et `plotly` (en utilisant `ggplotly` par exemple).\n\n        ::: {.cell teacher='true'}\n        \n        ```{.r .cell-code}\n        gg.H <- ggplot(df)+aes(x=maxO3)+geom_histogram(bins = 10)\n        am.H <- amHist(df$maxO3)\n        pl.H <- ggplotly(gg.H)\n        ```\n        :::\n\n    c.  Construire le modèle linéaire permettant d'expliquer **maxO3** par les autres variables. Calculer les résidus studentisés (`rstudent`) et visualiser ces résidus en fonction de la variable **maxO3**. Là encore on pourra ajouter un lisseur sur le graphe.\n\n        ::: {.cell teacher='true'}\n        \n        ```{.r .cell-code}\n        mod <- lm(maxO3~.,data=df)\n        res <- rstudent(mod)\n        df1 <- data.frame(maxO3=df$maxO3,r.student=res)\n        Ggg <- ggplot(df1)+aes(x=maxO3,y=res)+geom_point()+geom_smooth()\n        Gggp <- ggplotly(Ggg)\n        ```\n        :::\n\n2.  On peut maintenant passer au tableau de bord. On utilise le menu **File -\\> Rmarkdown -\\> From Template -\\> Flex Dashboard**.\n\n    a.  Construire un premier dashboard permettant de visualiser :\n\n        -   le jeu de données sur une colonne (on pourra utiliser la fonction **datatable** du package **DT**)\n\n        -   l'histogramme de la variable `maxO3` ainsi que la matrice des corrélations entre les variables quantitatives.\n\n    b.  Ajouter un nouvel onglet qui permet de visualiser le **summary** du modèle linéaire complet. On pourra utiliser la fonction **datatable** du package `DT`. **Indication** : ce nouvel onglet peut se créer avec\n\n        ::: {.cell}\n        \n        ```{.markdown .cell-code}\n        Name of the tab\n        =====================================  \n        ```\n        :::\n\n    c.  Ajouter un nouvel onglet qui permet de visualiser un modèle linéaire simple avec la variable explicative de votre choix. On pourra afficher dans cet onglet le **summary** du modèle ainsi que le nuage de points et la droite de régression.\n\n    d.  **Pour aller plus loin** : ajouter un dernier onglet qui permette à l'utilisateur de choisir la variable explicative du modèle simple. **Indications** : on pourra utiliser les commandes `Shiny`\n\n        -   Choix de la variable\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            radioButtons(\"variable1\",\n                        label=\"Choisir la variable explicative\",\n                        choices=names(df)[-1],\n                        selected=list(\"T9\"))\n            ```\n            :::\n\n        -   Mise à jour du résumé\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            mod1 <- reactive({\n              XX <- paste(input$variable1,collapse=\"+\")\n              form <- paste(\"maxO3~\",XX,sep=\"\") |> formula()\n              lm(form,data=df)\n              })\n            #Df correspond au jeu de données\n            renderDataTable({\n              mod.sum1 <- summary(mod1())$coefficients |> round(3) |> as.data.frame()\n              DT::datatable(mod.sum1,options = list(dom = 't'))\n            })\n            ```\n            :::\n\n        -   Mise à jour du graph interactif\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            renderPlotly({\n              (ggplot(df)+aes(x=!!as.name(input$variable1),y=maxO3)+\n                 geom_point()+geom_smooth(method=\"lm\")) |> ggplotly()\n            })\n            ```\n            :::\n\n            Enfin il ne faudra pas oublier d'ajouter\n\n            ::: {.cell}\n            \n            ```{.markdown .cell-code}\n            runtime: shiny\n            ```\n            :::\n\n    e.  Ajouter un dernier onglet permettant de choisir les variables explicatives dans le modèle linéaire. Là encore on pourra utiliser des commandes **Shiny**, par exemple\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        checkboxGroupInput(\"variable\",\n                           label=\"Choisir la variable\",\n                           choices=names(df)[-1],\n                           selected=list(\"T9\"))\n        ```\n        :::\n\n        Pour les variables choisies, on affichera dans ce nouvel onglet les coefficients du modèle linéaire ainsi que le graphe des résidus studentisés.\n\nLe tableau de bord finalisé pourra ressembler à\n\n::: {.cell name='app_dash_html' screenshot.opts='{\"delay\":5,\"cliprect\":\"viewport\",\"zoom\":2,\"vwidth\":200,\"vheight\":200}'}\n::: {.cell-output-display}\n[![](06-interactif_files/figure-epub/unnamed-chunk-43-1.png){width=760 height=750}](https://lrouviere.shinyapps.io/dashboard/)\n:::\n:::\n\n::: {.cell name='app_dash_pdf'}\n\n:::\n\nIl est disponible à l'url <https://lrouviere.shinyapps.io/dashboard/>\n:::\n",
    "supporting": [
      "06-interactif_files/figure-epub"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}