{
  "hash": "196af69651e60f9c6a0937b79dc6f6d8",
  "result": {
    "markdown": "\n::: {.content-visible when-format=\"html\"}\n::: {.cell}\n\\newcommand{\\prob}{\\mathbf P}\n\\newcommand{\\lt}{<}\n\\newcommand{\\mt}{>}\n:::\n\n```{=html}\n<style>\ndiv.correction {\n  color: black;\n  background-color: #F0F0F0;\n  font-style: normal;\n  /*display: none;*/\n}\n\n.corR {\n  font-style: italic;\n  /*display: none;*/\n}\n</style>\n```\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\\solntrue\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n# Faire des cartes avec R {#sec-carto}\n\nDe nombreuses données comportent des informations de géolocalisation. Il est alors naturel d'utiliser des cartes pour les visualiser. On peut généralement s'intéresser à deux types de cartes :\n\n-   **statiques** : des cartes figées que l'on pourra exporter aux formats **pdf** ou **png** par exemple, ce type est généralement utilisé pour des rapports ;\n-   **dynamiques** ou **interactives** : des cartes que l'on pourra visualiser dans un navigateur et sur lesquelles on pourra zoomer ou obtenir des informations auxiliaires lorsqu'on clique sur certaines parties de la carte.\n\nDe nombreux packages **R** permettent d'obtenir des cartes. Dans cette partie, on s'intéressera aux packages `ggmap` et `sf` pour les cartes statiques et `leaflet` pour les cartes interactives.\n\n## Le package ggmap\n\nNous montrons dans cette section comment récupérer des fonds de carte et ajouter quelques informations à l'aide de `ggmap`. Pour plus de détails sur ce package, on pourra consulter [cet article](https://journal.r-project.org/archive/2013-1/kahle-wickham.pdf) pour plus de détails.\n\n**ggmap** permet de récupérer facilement des fonds de carte. Par exemple :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggmap)\nus <- c(left = -125, bottom = 25.75, right = -67, top = 49)\nmap <- get_stamenmap(us, zoom = 5, maptype = \"toner-lite\")\nggmap(map)\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-2-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nPour l'Europe on fait\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\neurope <- c(left = -12, bottom = 35, right = 30, top = 63)\nget_stamenmap(europe, zoom = 5,\"toner-lite\") |> ggmap()\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-3-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nOn peut également changer le fond de carte\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_stamenmap(europe, zoom = 5,\"toner-background\") |> ggmap()\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-4-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nPour la France, on aura\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfr <- c(left = -6, bottom = 41, right = 10, top = 52)\nget_stamenmap(fr, zoom = 5,\"toner-lite\") |> ggmap()\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-5-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nLa fonction `geocode` de `tiygecoder` permet de récupérer des latitudes et longitudes à partir d'adresses :\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl <- tibble(address=c(\"the white house\",\"Paris\",\"Rennes\"))\nlibrary(tidygeocoder)\ntbl |> geocode(address)\n## # A tibble: 3 x 3\n##   address           lat   long\n##   <chr>           <dbl>  <dbl>\n## 1 the white house  38.9 -77.0 \n## 2 Paris            48.9   2.32\n## 3 Rennes           48.1  -1.68\n```\n:::\n\n\n\n\n\n\n::: {#exr-exo-carto-ggmap name=\"Populations des grandes villes de france\"}\n\\\n\n1.  Récupérer les latitudes et longitudes de Paris, Lyon et Marseille et représenter ces 3 villes sur une carte de la France.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    V <- tibble(ville=c(\"Paris\",\"Lyon\",\"Marseille\"))\n    A <- V |> geocode(ville) |> mutate(Villes=V)\n    fr <- c(left = -6, bottom = 41, right = 10, top = 52)\n    fond <- get_stamenmap(fr, zoom = 5,\"toner-lite\") \n    ggmap(fond)+geom_point(data=A,aes(x=long,y=lat),color=\"red\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-7-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n2.  Le fichier **villes_fr.csv** contient les populations des 30 plus grandes villes de france. Représenter à l'aide d'un point les 30 plus grandes villes de France. On fera varier la taille du point en fonction de la population en 2014.\n\n\n\n    ::: {.cell}\n    \n    :::\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    df <- read_csv(\"data/villes_fr.csv\")\n    df$Commune <- as.character(df$Commune)\n    ```\n    :::\n\n\n\n    ::: {.corR data-latex=\"\"}\n    Attention, la ville de Lille n'est pas bien écrite ! Il faut la renommer :\n    :::\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    df$Commune[10]    \n    ## [1] \"Lille15\"\n    df$Commune[10] <- \"Lille\"\n    ```\n    :::\n\n\n\n    ::: {.corR data-latex=\"\"}\n    On calcule les coordonnées avec **geocode** et on représente les ville. Pour la taille des points, il suffit d'ajouter **size=`2014`** dans l'`aes` du `geom_point`.\n    :::\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    coord <- df |> tidygeocoder::geocode(Commune)\n    ggmap(fond)+geom_point(data=coord,aes(x=long,y=lat,size=`2014`),color=\"red\")\n    ```\n    :::\n\n    ::: {.cell}\n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-12-1.pdf)\n    :::\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-12-2.pdf)\n    :::\n    :::\n\n\n:::\n\n## Cartes avec contours, le format shapefile\n\n`ggmap` permet de récupérer facilement des fonds de cartes et de placer des points dessus avec la syntaxe `ggplot`. Cependant, de nombreuses fonctions de ca package nécessitent une API et il est difficile de définir des contours (frontières de pays, départements ou régions) avec `ggmap`. Nous proposons ici de présenter brièvement le package **sf** qui va nous permettre de créer des cartes \"avancées\", en gérant les contours à l'aide d'objets particuliers mais aussi en prenant en compte différents systèmes de coordonnées. En effet, la terre n'est pas plate... mais une carte est souvent visualisée en 2D, il faut par conséquent réaliser des projections pour représenter des lieux définis par une coordonnée (comme la latitude et la longitude) sur une carte 2D. Ces projections sont généralement gérées par les packages qui permettent de faire de la cartographie comme **sf**. On pourra trouver de la documentation sur ce package aux url suivantes :\n\n-   <https://statnmap.com/fr/2018-07-14-initiation-a-la-cartographie-avec-sf-et-compagnie/>\n-   dans les **vignettes** sur la page du cran de ce package : <https://cran.r-project.org/web/packages/sf/index.html>\n\nCe package propose de définir un nouveau format **sf** adapté à la cartographie. Regardons par exemple l'objet **nc**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nnc <- st_read(system.file(\"shape/nc.shp\", package = \"sf\"), quiet = TRUE)\nclass(nc)\n## [1] \"sf\"         \"data.frame\"\nnc\n## Simple feature collection with 100 features and 14 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\n## Geodetic CRS:  NAD27\n## First 10 features:\n##     AREA PERIMETER CNTY_ CNTY_ID        NAME  FIPS FIPSNO CRESS_ID BIR74 SID74\n## 1  0.114     1.442  1825    1825        Ashe 37009  37009        5  1091     1\n## 2  0.061     1.231  1827    1827   Alleghany 37005  37005        3   487     0\n## 3  0.143     1.630  1828    1828       Surry 37171  37171       86  3188     5\n## 4  0.070     2.968  1831    1831   Currituck 37053  37053       27   508     1\n## 5  0.153     2.206  1832    1832 Northampton 37131  37131       66  1421     9\n## 6  0.097     1.670  1833    1833    Hertford 37091  37091       46  1452     7\n## 7  0.062     1.547  1834    1834      Camden 37029  37029       15   286     0\n## 8  0.091     1.284  1835    1835       Gates 37073  37073       37   420     0\n## 9  0.118     1.421  1836    1836      Warren 37185  37185       93   968     4\n## 10 0.124     1.428  1837    1837      Stokes 37169  37169       85  1612     1\n##    NWBIR74 BIR79 SID79 NWBIR79                       geometry\n## 1       10  1364     0      19 MULTIPOLYGON (((-81.47276 3...\n## 2       10   542     3      12 MULTIPOLYGON (((-81.23989 3...\n## 3      208  3616     6     260 MULTIPOLYGON (((-80.45634 3...\n## 4      123   830     2     145 MULTIPOLYGON (((-76.00897 3...\n## 5     1066  1606     3    1197 MULTIPOLYGON (((-77.21767 3...\n## 6      954  1838     5    1237 MULTIPOLYGON (((-76.74506 3...\n## 7      115   350     2     139 MULTIPOLYGON (((-76.00897 3...\n## 8      254   594     2     371 MULTIPOLYGON (((-76.56251 3...\n## 9      748  1190     2     844 MULTIPOLYGON (((-78.30876 3...\n## 10     160  2038     5     176 MULTIPOLYGON (((-80.02567 3...\n```\n:::\n\n\n\nCes données contiennent des informations sur les morts subites de nourissons dans des villes de Caroline du Nord. On remarque que l'objet `nc` est au format `sf` et `data.frame`. On peut donc l'utiliser comme un `data.frame` classique. Le format `sf` permet l'ajout d'une colonne particulière (`geometry`) qui délimitera les villes à l'aide de polygones. Une fois l'objet obtenu au format **sf**, il est facile de visualiser la carte avec un **plot** classique\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(nc))\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-14-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nou en utilisant le verbe `geom_sf` si on veut faire du `ggplot`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(nc)+geom_sf()\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-15-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nIl devient dès lors facile de colorier des villes et d'ajouter leurs noms :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(nc[1:3,]) +\n   geom_sf(aes(fill = AREA)) + \n   geom_sf_label(aes(label = NAME))\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-16-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nLa colonne `geometry` de `nc` est au format `MULTIPOLYGON`, elle permettra donc de délimiter les frontières des villes. Si maintenant on souhaite représenter une ville à l'aide d'un point défini par sa latitude et longitude, il va falloir modifier le format de cette colonne `geometry`. On peut le faire de la manière suivante :\n\n1.  On récupère les latitudes et longitudes de chaque ville :\n\n\n\n    ::: {.cell}\n    \n    :::\n\n    ::: {.cell}\n    \n    :::\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    coord.ville.nc <- nc |> tidygeocoder::geocode(NAME)\n    ```\n    :::\n\n\n\n2.  On met ces coordonnées au format `MULTIPOINT`\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    coord.ville1.nc <- coord.ville.nc |> select(long,lat) |> \n      filter(long<=-77 & long>=-85 & lat>=33 & lat<=37) |> \n      as.matrix() |> st_multipoint()  |> st_geometry() |> st_cast(to=\"POINT\")\n    coord.ville1.nc\n    ## Geometry set for 50 features \n    ## Geometry type: POINT\n    ## Dimension:     XY\n    ## Bounding box:  xmin: -83.83378 ymin: 34.27511 xmax: -77.01151 ymax: 36.503\n    ## CRS:           NA\n    ## First 5 geometries:\n    ## POINT (-81.50766 36.43936)\n    ## POINT (-81.13408 36.503)\n    ## POINT (-80.70138 36.41356)\n    ## POINT (-77.01151 36.35605)\n    ## POINT (-80.22881 36.4121)\n    ```\n    :::\n\n\n\n3.  On indique que ces coordonnées sont des latitudes et longitude et on ajoute la colonne aux données initiales\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    st_crs(coord.ville1.nc) <- 4326 \n    ```\n    :::\n\n\n\n4.  On peut enfin représenter la carte avec les frontières et les points :\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ggplot(nc)+geom_sf()+geom_sf(data=coord.ville1.nc)\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-22-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\nLe package `sf` possède également des fonctions très utiles pour traiter des données cartographiques, on peut citer par exemple :\n\n-   `st_distance` qui permet de calculer des distances entre coordonnées ;\n-   `st_centroid` pour calculer le centre d'une région ;\n-   ...\n\nOn peut ainsi représenter les centres des villes délimitées par les polygones des données `nc` avec\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnc2 <- nc |> mutate(centre=st_centroid(nc)$geometry)\nggplot(nc2)+geom_sf()+geom_sf(aes(geometry=centre))\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-23-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n::: {#exr-exo-carto-sf1 name=\"Première carte avec sf\"}\nNous nous servons de la carte GEOFLAR proposée par l'Institut Géographique National pour récupérer un fond de carte contenant les frontières des départements français. Cette carte est disponible sur le site [http: //professionnels.ign.fr/](http:%20//professionnels.ign.fr/) au format **shapefile**, elle se trouve dans l'archive **dpt.zip**. Il faut décompresser pour reproduire la carte. Grâce au package `sf`, cette carte, contenue dans la série de fichiers département du répertoire **dpt**, peut être importée dans un objet R :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndpt <- read_sf(\"data/dpt\")\nggplot(dpt) + geom_sf()\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-24-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nRefaire la carte de l'@exr-exo-carto-ggmap sur ce fond de carte.\n\n::: {.corR data-latex=\"\"}\nOn définit tout d'abord un `geometry` au format `MULTIPOINT`. On le transforme ensuite en un \"vecteur\" de longueur 30 au format `POINT` que l'on ajoute dans la dataframe qui contient les coordonnées des villes.\n:::\n\n\n\n::: {.cell teacher='true'}\n\n```{.r .cell-code}\ncoord.ville1 <- data.frame(df1[,14:15]) |> \n  as.matrix() |> st_multipoint() |> st_geometry()\ncoord.ville2 <- st_cast(coord.ville1, to = \"POINT\")\ncoord.ville1\n## Geometry set for 1 feature \n## Geometry type: MULTIPOINT\n## Dimension:     XY\n## Bounding box:  xmin: -4.486009 ymin: 42.69853 xmax: 7.750713 ymax: 50.63657\n## CRS:           NA\n## MULTIPOINT ((2.351462 48.8567), (5.369953 43.29...\ncoord.ville2\n## Geometry set for 30 features \n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: -4.486009 ymin: 42.69853 xmax: 7.750713 ymax: 50.63657\n## CRS:           NA\n## First 5 geometries:\n## POINT (2.351462 48.8567)\n## POINT (5.369953 43.29617)\n## POINT (4.832011 45.75781)\n## POINT (1.444247 43.60446)\n## POINT (7.268391 43.70094)\n```\n:::\n\n\n\n::: {.corR data-latex=\"\"}\nOn peut maintenant visualiser la carte demandée.\n:::\n\n\n\n::: {.cell teacher='true'}\n\n```{.r .cell-code}\nst_geometry(df1) <- coord.ville2\nst_crs(df1) <- 4326\ndf1\n## Simple feature collection with 30 features and 15 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: -4.486009 ymin: 42.69853 xmax: 7.750713 ymax: 50.63657\n## Geodetic CRS:  WGS 84\n## # A tibble: 30 x 16\n##     Rang Commune    Département Région `1968` `1975` `1982` `1990` `1999` `2006`\n##  * <dbl> <chr>      <chr>       <chr>   <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>\n##  1     1 Paris      Paris       Île-d~ 2.59e6 2.30e6 2.18e6 2.15e6 2.13e6 2.18e6\n##  2     2 Marseille  Bouches-du~ Prove~ 8.89e5 9.09e5 8.74e5 8.01e5 7.96e5 8.39e5\n##  3     3 Lyon       Métropole ~ Auver~ 5.28e5 4.57e5 4.13e5 4.15e5 4.45e5 4.72e5\n##  4     4 Toulouse   Haute-Garo~ Occit~ 3.71e5 3.74e5 3.48e5 3.59e5 3.90e5 4.38e5\n##  5     5 Nice       Alpes-Mari~ Prove~ 3.22e5 3.44e5 3.37e5 3.42e5 3.43e5 3.47e5\n##  6     6 Nantes     Loire-Atla~ Pays ~ 2.60e5 2.57e5 2.41e5 2.45e5 2.70e5 2.83e5\n##  7     7 Strasbourg Bas-Rhin    Grand~ 2.49e5 2.53e5 2.49e5 2.52e5 2.64e5 2.73e5\n##  8     8 Montpelli~ Hérault     Occit~ 1.62e5 1.91e5 1.97e5 2.08e5 2.25e5 2.52e5\n##  9     9 Bordeaux   Gironde     Nouve~ 2.67e5 2.23e5 2.08e5 2.10e5 2.15e5 2.32e5\n## 10    10 Lille      Nord        Hauts~ 2.39e5 2.19e5 1.97e5 1.99e5 2.13e5 2.26e5\n## # i 20 more rows\n## # i 6 more variables: `2011` <dbl>, `2013` <dbl>, `2014` <dbl>, lon <dbl>,\n## #   lat <dbl>, geometry <POINT [°]>\nggplot(dpt)+geom_sf(fill=\"white\")+\n  geom_sf(data=df1,aes(size=`2014`),color=\"red\")+theme_void()\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-26-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::\n\n::: {#exr-exo-carto-sf-tc name=\"Visualisation de taux de chômage avec sf\"}\nNous souhaitons visualiser graphiquement les différences de taux de chômage par département entre deux années. Pour cela, nous disposons de chaque taux mesuré aux premiers trimestres des années 2006 et 2011 (variables `TCHOMB1T06`, `TCHOMB1T11`) qui se trouvent dans le jeu de données `tauxchomage.csv`.\n\n1.  Importer le jeu de données.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    chomage <- read_delim(\"data/tauxchomage.csv\",delim=\";\")\n    ```\n    :::\n\n\n\n2.  Faire la jointure de cette table avec celle des frontières des départements. On pourra utiliser **inner_join**.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    dpt <- read_sf(\"data/dpt\")\n    dpt2 <- inner_join(dpt,chomage,by=\"CODE_DEPT\")\n    ```\n    :::\n\n\n\n3.  Comparer les taux de chômage en 2006 et 2011 (on le fera avec une carte pour les taux en 2006 et une autre pour les taux en 2011).\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    dpt3 <- dpt2 |> select(A2006=TCHOMB1T06,A2011=TCHOMB1T11,geometry) |>\n      as_tibble() |> \n      pivot_longer(-geometry,names_to=\"Annee\",values_to=\"TxChomage\") |>\n      st_as_sf()\n    ```\n    :::\n\n    ::: {.cell}\n    \n    :::\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(dpt3) + aes(fill = TxChomage)+geom_sf() +\n      facet_wrap(~Annee, nrow = 1)+\n      scale_fill_gradient(low=\"white\",high=\"brown\")+theme_bw()\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-31-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n:::\n\n### Challenge 1 : carte des températures avec sf {#sec-challenge1}\n\nOn souhaite ici faire une carte permettant de visualiser les température en France à un moment donné. Les données se trouvent sur le site des [données publiques de meteo france](https://donneespubliques.meteofrance.fr/?fond=produit&id_produit=90&id_rubrique=32). On peut notamment récupérer\n\n-   les températures observées dans certaines stations en France les 15 derniers jours dans le lien téléchargement. On utilisera uniquement les identifiants de la station ainsi que la température observée (colonne `t`).\n-   la géolocalisation de ces stations dans le lien [documentation](https://donneespubliques.meteofrance.fr/donnees_libres/Txt/Synop/postesSynop.csv)\n\n1.  Importer les 2 bases nécessaires. On pourra les lire directement sur le site. Convertir les degrés Kelvin en degrés Celsius et faire la jointure de ces bases.\n\n\n\n    ::: {.cell}\n    \n    :::\n\n    ::: {.cell}\n    \n    :::\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    donnees <- read_delim(\"https://donneespubliques.meteofrance.fr/donnees_libres/Txt/Synop/synop.2021122415.csv\",delim=\";\",col_types = cols(t=col_double()))\n    station <- read_delim(\"https://donneespubliques.meteofrance.fr/donnees_libres/Txt/Synop/postesSynop.csv\",delim=\";\")\n    donnees$t <- donnees$t-273.15 #on passe en degrés celcius\n    temp <- donnees |> select(numer_sta,t)\n    names(temp)[1] <- c(\"ID\")\n    D <- inner_join(temp, station, by = c(\"ID\"))\n    ```\n    :::\n\n\n\n2.  Éliminer les station d'outre mer (on pourra conserver uniquement les stations qui ont une longitude entre -20 et 25). On appellera ce tableau **station1**. Visualiser les stations sur la carte contenant les frontières des départements français.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    station1 <- D |> filter(Longitude<25 & Longitude>-20) |> na.omit()\n    station4326 <- st_multipoint(as.matrix(station1[,5:4])) |> st_geometry()\n    st_crs(station4326) <- 4326\n    ggplot(dpt) + geom_sf()+geom_sf(data=station4326)\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-35-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n3.  Créer un dataframe au format **sf** qui contient les températures des stations ainsi que leurs coordonnées dans la colonne **geometry**. On pourra commencer avec\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    station2 <- station1 |> select(Longitude,Latitude) |> \n      as.matrix() |> st_multipoint() |> st_geometry()\n    st_crs(station2) <- 4326\n    station2 <- st_cast(station2, to = \"POINT\")\n    ```\n    :::\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    df <- data.frame(temp=station1$t)\n    st_geometry(df) <- station2\n    ```\n    :::\n\n\n\n4.  Représenter les stations sur une carte de france. On pourra mettre un point de couleur différente en fonction de la température.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(dpt) + geom_sf(fill=\"white\")+\n      geom_sf(data=df,aes(color=temp),size=2)+\n      scale_color_continuous(low=\"yellow\",high=\"red\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-38-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n5.  On obtient les coordonnées des centroïdes des départements à l'aide de\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    centro <- st_centroid(dpt$geometry) \n    centro <- st_transform(centro,crs=4326)\n    ```\n    :::\n\n\n\n    On déduit les distances entre ces centroïdes et les stations avec (**df** étant la table **sf** obtenue à la question 3).\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    DD <- st_distance(df,centro)\n    ```\n    :::\n\n\n\n    Prédire la température de chaque département à l'aide de la règle du 1 plus proche voisin (la température du département $i$ sera celle de la station la plus proche du centroïde de $i$).\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    NN <- apply(DD,2,order)[1,]\n    t_prev <- station1[NN,2]\n    ```\n    :::\n\n\n\n6.  Colorier les départements en fonction de la température prédite dans le département. On pourra faire varier le dégradé de couleur du jaune (pour les faibles températures) au rouge (pour les fortes).\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    dpt1 <- dpt |> mutate(t_prev=as.matrix(t_prev))\n    ggplot(dpt1) + geom_sf(aes(fill=t_prev)) +\n      scale_fill_continuous(low=\"yellow\",high=\"red\")+theme_void()\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-42-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n    ::: {.corR data-latex=\"\"}\n    On peut supprimer les lignes de frontières avec\n    :::\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    ggplot(dpt1) + geom_sf(aes(fill=t_prev,color=t_prev)) + \n      scale_fill_continuous(low=\"yellow\",high=\"red\") + \n      scale_color_continuous(low=\"yellow\",high=\"red\")+theme_void()\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-43-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n### Trouver des cartes au format shapefile\n\nLe plus souvent on ne va pas construire les fonds de carte au format shapefile \"à la main\" et il est bien entendu important de récupérer ces fonds de carte au préalable. La méthode la plus courante consiste à taper les bons mots clefs sur un moteur de recherche... On pourra par exemple utiliser :\n\n-   des **packages R**, par exemple `rnaturalearth`:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    world <- rnaturalearth::ne_countries(scale = \"medium\", returnclass = \"sf\")\n    class(world)\n    ## [1] \"sf\"         \"data.frame\"\n    ggplot(data = world) +\n    geom_sf(aes(fill = pop_est)) +\n    scale_fill_viridis_c(option = \"plasma\", trans = \"sqrt\")+theme_void()\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-44-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n    On peut aussi visualiser la térre comme une sphère :\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ggplot(data = world) +\n    geom_sf() +\n    coord_sf(crs = \"+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs \")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-45-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n    Voir <https://www.r-spatial.org/r/2018/10/25/ggplot2-sf.html> pour plus de détails.\n\n-   le **web**, par exemple le site [data gouv](https://www.data.gouv.fr/fr/datasets/contours-des-regions-francaises-sur-openstreetmap/#_):\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    regions <- read_sf(\"data/regions-20180101-shp/\")\n    ```\n    :::\n\n\n\n    Attention, la taille des objets peut être très (trop) grande\\\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    format(object.size(regions),units=\"Mb\")\n    ## [1] \"15.4 Mb\"\n    ```\n    :::\n\n\n\n    et la construction de la carte peut dans ce cas prendre beaucoup de temps... On peut réduire la taille avec ce type d'outils\\\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(rmapshaper)\n    regions1 <- ms_simplify(regions)\n    format(object.size(regions1),units=\"Mb\")\n    ## [1] \"0.9 Mb\"\n    ggplot(regions1)+geom_sf()+\n      coord_sf(xlim = c(-5.5,10),ylim=c(41,51))+theme_void()\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-48-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n## Cartes interactives avec leaflet\n\n`Leaflet` est un package permettant de faire de la *cartographie interactive*. On pourra consulter un descriptif synthétique [ici](https://rstudio.github.io/leaflet/). Le principe est similaire à ce qui a été présenté précédemment : les cartes sont construites à partir de couches qui se superposent. Un fond de carte s'obtient avec les fonctions `leaflet` et `addTiles`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(leaflet)\nleaflet() |> addTiles()\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-49-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nOn dispose de plusieurs styles de fonds de cartes (quelques exemples [ici](http://leaflet-extras.github.io/leaflet-providers/preview/)) :\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nParis <- tibble(V=\"Paris\") |> tidygeocoder::geocode(V)\nm2 <- leaflet() |> setView(lng = as.numeric(Paris[1,3]), \n                           lat = as.numeric(Paris[1,2]), zoom = 12) |> \n  addTiles()\nm2 |> addProviderTiles(\"Stamen.Toner\")\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-51-1.pdf){fig-pos='H'}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nm2 |> addProviderTiles(\"Wikimedia\")\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-52-1.pdf){fig-pos='H'}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nm2 |> addProviderTiles(\"Esri.NatGeoWorldMap\")\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-53-1.pdf){fig-pos='H'}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nm2 |>\n  addProviderTiles(\"Stamen.Watercolor\") |>\n  addProviderTiles(\"Stamen.TonerHybrid\")\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-54-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nIl est souvent utile de repérer des lieux sur une carte à l'aide de symboles. On pourra effectuer cela à l'aide des fonctions `addMarkers` et `addCircles`...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(quakes)\nleaflet(data = quakes[1:20,]) |> addTiles() |>\n  addMarkers(~long, ~lat, popup = ~as.character(mag))\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-55-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nOn remarque que l'on utilise ici un **tilde** pour spécifier qu'on utilise des variables dans un `dataframe`.\n\nLe caractère interactif de la carte permet d'ajouter de l'information lorsqu'on clique sur un marker (grâce à l'option `popup`). On peut également ajouter des **popups** qui contiennent plus d'information, voire des liens vers des sites web :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontent <- paste(sep = \"<br/>\",\n  \"<b><a href='http://www.samurainoodle.com'>Samurai Noodle</a></b>\",\n  \"606 5th Ave. S\",\n  \"Seattle, WA 98138\"\n)\n\nleaflet() |> addTiles() |>\n  addPopups(-122.327298, 47.597131, content,\n    options = popupOptions(closeButton = FALSE)\n  )\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-56-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n::: {#exr-exo-carto-popup-leaflet name=\"Popup avec leaflet\"}\nPlacer un **popup** localisant l'Université Rennes 2 (Campus Villejean). On ajoutera un lien renvoyant sur le site de l'Université.\n\n\n\n::: {.cell teacher='true'}\n\n```{.r .cell-code}\nR2 <- tibble(V=\"Universite Rennes Villejean\") |> tidygeocoder::geocode(V)\ninfo <- paste(sep = \"<br/>\",\n  \"<b><a href='https://www.univ-rennes2.fr'>Universite Rennes 2</a></b>\",\n  \"Campus Villejean\")\n\n\nleaflet() |> addTiles() |>  \n  addPopups(as.numeric(R2[1,3]$long), as.numeric(R2[1,2]$lat), info,options = popupOptions(closeButton = FALSE))\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-57-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::\n\n### Challenge 2 : Visualisation des stations velib à Paris\n\nPlusieurs villes dans le monde ont accepté de mettre en ligne les données sur l'occupation des stations velib. Ces données sont facilement accessibles et mises à jour en temps réel. On dispose généralement de la taille et la localisation des stations, la proportion de vélos disponibles... Il est possible de requêter (entre autres) :\n\n-   sur les données [Decaux](https://developer.jcdecaux.com/#/opendata/vls?page=getstarted)\n-   sur [Open data Paris](https://opendata.paris.fr/pages/home/)\n-   sur [vlstats](http://vlsstats.ifsttar.fr/rawdata) pour des données mensuelles ou historiques ou encore sur Velib pour obtenir des fichiers qui sont rafraîchis régulièrement.\n\n1.  Récupérer les données actuelles de velib disponibles pour la ville de Paris : <https://opendata.paris.fr/explore/dataset/velib-disponibilite-en-temps-reel/information/>. On pourra utiliser la fonction `read_delim` avec l'option `delim=\";\"`.\n\n\n\n    ::: {.cell}\n    \n    :::\n\n    ::: {.cell}\n    \n    :::\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    lien <- \"https://opendata.paris.fr/explore/dataset/velib-disponibilite-en-temps-reel/download/?format=csv&timezone=Europe/Berlin&use_labels_for_header=true\"\n    sta.Paris <- read_delim(lien,delim=\";\")\n    ```\n    :::\n\n\n\n2.  Décrire les variables du jeu de données.\n\n    ::: {.corR data-latex=\"\"}\n    Nous avons de l'information sur la disponibilité, le remplissage... de stations velib parisiennes.\n    :::\n\n3.  Créer une variable `latitude` et une variable `longitude` à partir de la variable `Coordonnées géographiques`. On pourra utiliser la fonction **separate** du package `tidyr`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    sta.Paris1 <- sta.Paris |> separate(`Coordonnées géographiques`,\n                                     into=c(\"lat\",\"lon\"),sep=\",\") |> \n      mutate(lat=as.numeric(lat),lon=as.numeric(lon))\n    ```\n    :::\n\n\n\n4.  Visualiser les positions des stations sur une carte leaflet. On pourra utiliser l'option `clusterOptions = markerClusterOptions()` pour que la carte soit plus claire.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    map.velib1 <- leaflet(data = sta.Paris1) |> \n      addTiles() |>\n      addCircleMarkers(~ lon, ~ lat,radius=3,\n    stroke = FALSE, fillOpacity = 0.5,color=\"red\"\n      )\n    \n    map.velib1\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-62-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n    ::: {.corR data-latex=\"\"}\n    La carte est peu lisible, il y a en effet beaucoup de stations et il est difficile de bien les visualiser. Les choses deviennent plus claires en visualisant es groupes de station :\n    :::\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    leaflet(sta.Paris1) |> addTiles() |> \n      addMarkers(~ lon, ~ lat,clusterOptions = markerClusterOptions())\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-63-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n5.  Ajouter un popup qui permet de connaitre le nombre de vélos disponibles (électriques+mécanique) quand on clique sur la station (on pourra utiliser l'option **popup** dans la fonction **addCircleMarkers**).\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    leaflet(data = sta.Paris1) |> \n      addTiles() |> \n      addMarkers(~ lon, ~ lat,clusterOptions = markerClusterOptions(),\n                 popup = ~ sprintf(\"<b> Vélos dispos : %s</b>\",\n                                     as.character(`Nombre total vélos disponibles`)))\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-64-1.pdf){fig-pos='H'}\n    :::\n    \n    ```{.r .cell-code}\n    \n    #ou sans sprintf\n    \n    leaflet(data = sta.Paris1) |> \n      addTiles() |> \n      addMarkers(~ lon, ~ lat,clusterOptions = markerClusterOptions(),\n                 popup = ~ paste(\"<b> Vélos dispos </b>:\",\n                                   as.character(`Nombre total vélos disponibles`)))\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-64-2.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n6.  Ajouter la nom de la station dans le popup.\n\n\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    leaflet(data = sta.Paris1) |> \n      addTiles() |>\n      addMarkers(~ lon, ~ lat,clusterOptions = markerClusterOptions(),\n                 popup = ~ paste(as.character(`Nom station`),\"<br/><b> Vélos dispos </b>:\",\n                                 as.character(`Nombre total vélos disponibles`)))\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-65-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n7.  Faire de même en utilisant des couleurs différentes en fonction de la proportion de vélos disponibles dans la station. On pourra utiliser les palettes de couleur\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ColorPal1 <- colorNumeric(scales::seq_gradient_pal(low = \"#132B43\", high = \"#56B1F7\",\n                                                   space = \"Lab\"), domain = c(0,1.2))\n    ColorPal2 <- colorNumeric(scales::seq_gradient_pal(low = \"red\", high = \"black\", \n                                                   space = \"Lab\"), domain = c(0,1.2))\n    ```\n    :::\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    leaflet(data = sta.Paris1) |> \n      addTiles() |>\n      addCircleMarkers(~ lon, ~ lat,clusterOptions = markerClusterOptions(),\n                       stroke = FALSE, fillOpacity = 0.7,\n                       color=~ColorPal1(`Nombre total vélos disponibles`/\n                                          `Capacité de la station`), \n                       popup = ~ paste(as.character(`Nom station`),\"<br/><b> Vélos dispos </b>:\",\n                                       as.character(`Nombre total vélos disponibles`),\n                                       sep=\"\"))\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-67-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n    ::: {.cell teacher='true'}\n    \n    ```{.r .cell-code}\n    leaflet(data = sta.Paris1) |> \n      addTiles() |>\n      addCircleMarkers(~ lon, ~ lat,clusterOptions = markerClusterOptions(),\n                       stroke = FALSE, fillOpacity = 0.7,\n                       color=~ColorPal2(`Nombre total vélos disponibles`/\n                                          `Capacité de la station`),\n                       radius=~(`Nombre total vélos disponibles`/\n                              `Capacité de la station`)*40,\n                       popup = ~ paste(as.character(`Nom station`),\"<br/><b> Vélos dispos </b>:\",\n                                   as.character(`Nombre total vélos disponibles`),\n                                   sep=\"\"))\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-68-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n8.  Créer une fonction `local.station` qui permette de visualiser quelques stations autours d'une station choisie.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    nom.station <- \"Jussieu - Fossés Saint-Bernard\"\n    local.station <- function(nom.station){\n      df <- sta.Paris1 |> filter(`Nom station`==nom.station)\n      leaflet(data = sta.Paris1) |> setView(lng=df$lon,lat=df$lat,zoom=15) |>\n    addTiles() |> \n    addCircleMarkers(~ lon, ~ lat,stroke = FALSE, fillOpacity = 0.7,\n                    popup = ~ paste(as.character(`Nom station`),\", Vélos dispos :\",\n                                    as.character(`Nombre total vélos disponibles`),\n                                    sep=\"\")) |>\n    addMarkers(lng=df$lon,lat=df$lat,\n               popup = ~ paste(nom.station,\", Vélos dispos :\",\n                               as.character(df$`Nombre total vélos disponibles`),\n                               sep=\"\"),\n               popupOptions = popupOptions(noHide = T))\n    }\n    ```\n    :::\n\n\n\n    La fonction devra par exemple renvoyer\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    local.station(\"Jussieu - Fossés Saint-Bernard\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-70-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    local.station(\"Gare Montparnasse - Arrivée\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](05-carto_files/figure-pdf/unnamed-chunk-71-1.pdf){fig-pos='H'}\n    :::\n    :::\n\n\n\n### Carte des températures avec leaflet\n\n::: {#exr-leaflet-temp-challenge name=\"Challenge\"}\nRefaire la carte des températures du premier challenge (voir @sec-challenge1) en utilisant **leaflet**. On utilisera la table construite dans le challenge 1 et la fonction `addPolygons`. On pourra également ajouter un popup qui permet de visualiser le nom du département ainsi que la température prévue lorsqu'on clique dessus.\n\n\n\n::: {.cell teacher='true'}\n\n```{.r .cell-code}\ndpt2 <- st_transform(dpt1, crs = 4326)\ndpt2$t_prev <- round(dpt2$t_prev)\npal <- colorNumeric(scales::seq_gradient_pal(low = \"yellow\", high = \"red\",\n                                             space = \"Lab\"), domain = dpt2$t_prev)\nm <- leaflet() |> addTiles() |> \n  addPolygons(data = dpt2,color=~pal(t_prev),fillOpacity = 0.6, \n              stroke = TRUE,weight=1,\n              popup=~paste(as.character(NOM_DEPT),as.character(t_prev),sep=\" : \"),\n              highlightOptions = highlightOptions(color = \"black\", weight = 3,bringToFront = TRUE)) |> \n  addLayersControl(options=layersControlOptions(collapsed = FALSE))\nm\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-72-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n::: {.corR data-latex=\"\"}\nou avec une autre palette de couleur\n:::\n\n\n\n::: {.cell teacher='true'}\n\n```{.r .cell-code}\npal1 <- colorNumeric(palette = c(\"inferno\"),domain = dpt2$t_prev)\nm1 <- leaflet() |> addTiles() |> \n  addPolygons(data = dpt2,color=~pal1(t_prev),fillOpacity = 0.6, \n              stroke = TRUE,weight=1,\n              popup=~paste(as.character(NOM_DEPT),as.character(t_prev),sep=\" : \"),\n              highlightOptions = highlightOptions(color = \"black\", weight = 3,bringToFront = TRUE)) |> \n  addLayersControl(options=layersControlOptions(collapsed = FALSE))\nm1\n```\n\n::: {.cell-output-display}\n![](05-carto_files/figure-pdf/unnamed-chunk-73-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::\n",
    "supporting": [
      "05-carto_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}