```{r,child='_preamble.qmd'}
```




# Faire des cartes avec R {#sec-carto}

De nombreuses données comportent des informations de géolocalisation. Il est alors naturel d'utiliser des cartes pour les visualiser. On peut généralement s'intéresser à deux types de cartes :

-   **statiques** : des cartes figées que l'on pourra exporter aux formats **pdf** ou **png** par exemple, ce type est généralement utilisé pour des rapports ;
-   **dynamiques** ou **interactives** : des cartes que l'on pourra visualiser dans un navigateur et sur lesquelles on pourra zoomer ou obtenir des informations auxiliaires lorsqu'on clique sur certaines parties de la carte.

De nombreux packages **R** permettent d'obtenir des cartes. Dans cette partie, on s'intéressera aux packages `ggmap` et `sf` pour les cartes statiques et `leaflet` pour les cartes interactives.

## Le package ggmap

Nous montrons dans cette section comment récupérer des fonds de carte et ajouter quelques informations à l'aide de `ggmap`. Pour plus de détails sur ce package, on pourra consulter [cet article](https://journal.r-project.org/archive/2013-1/kahle-wickham.pdf) pour plus de détails.

**ggmap** permet de récupérer facilement des fonds de carte. Par exemple :




```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(ggmap)
us <- c(left = -125, bottom = 25.75, right = -67, top = 49)
map <- get_stamenmap(us, zoom = 5, maptype = "toner-lite")
ggmap(map)
```




Pour l'Europe on fait




```{r message=FALSE, warning=FALSE}
europe <- c(left = -12, bottom = 35, right = 30, top = 63)
get_stamenmap(europe, zoom = 5,"toner-lite") |> ggmap()
```




On peut également changer le fond de carte




```{r message=FALSE, warning=FALSE}
get_stamenmap(europe, zoom = 5,"toner-background") |> ggmap()
```




Pour la France, on aura




```{r message=FALSE, warning=FALSE}
fr <- c(left = -6, bottom = 41, right = 10, top = 52)
get_stamenmap(fr, zoom = 5,"toner-lite") |> ggmap()
```




La fonction `geocode` de `ggmap` qui permettait de récupérer des latitudes et longitudes nécessite désormais une **API**, ce qui contraint son utilisation. Nous proposons d'utiliser la fonction suivante :




```{r message=FALSE, warning=FALSE}
if (!(require(jsonlite))) install.packages("jsonlite")
mygeocode <- function(adresses){
# adresses est un vecteur contenant toutes les adresses sous forme de chaine de caracteres
  nominatim_osm <- function(address = NULL){
    ## details: http://wiki.openstreetmap.org/wiki/Nominatim
    ## fonction nominatim_osm proposée par D.Kisler
    if(suppressWarnings(is.null(address)))  return(data.frame())
    tryCatch(
      d <- jsonlite::fromJSON(
        gsub('\\@addr\\@', gsub('\\s+', '\\%20', address),
             'http://nominatim.openstreetmap.org/search/@addr@?format=json&addressdetails=0&limit=1')
      ), error = function(c) return(data.frame())
    )
    if(length(d) == 0) return(data.frame())
    return(c(as.numeric(d$lon), as.numeric(d$lat)))
  }
  tableau <- t(sapply(adresses,nominatim_osm))
  colnames(tableau) <- c("lon","lat")
  return(tableau)
}

```




Cette fonction permet de récupérer les latitudes et longitudes de lieux à spécifier :




```{r}
mygeocode("the white house")
mygeocode("Paris")
mygeocode("Rennes")
```




::: {#exr-exo-carto-ggmap name="Populations des grandes villes de france"}
\

1.  Récupérer les latitudes et longitudes de Paris, Lyon et Marseille et représenter ces 3 villes sur une carte de la France.




    ```{r,teacher=correct}
    V <- c("Paris","Lyon","Marseille")
    A <- mygeocode(V)
    A <- A |> as_tibble() |> mutate(Villes=V)
    fr <- c(left = -6, bottom = 41, right = 10, top = 52)
    fond <- get_stamenmap(fr, zoom = 5,"toner-lite") 
    ggmap(fond)+geom_point(data=A,aes(x=lon,y=lat),color="red")
    ```




2.  Le fichier **villes_fr.csv** contient les populations des 30 plus grandes villes de france. Représenter à l'aide d'un point les 30 plus grandes villes de France. On fera varier la taille du point en fonction de la population en 2014.




    ```{r,echo=FALSE,eval=FALSE}
    #pour aller plus vite
    df <- read_csv("data/villes_fr.csv")
    df$Commune <- as.character(df$Commune)
    df$Commune[10] <- "Lille"
    coord <- mygeocode(as.character(df$Commune)) |> as_tibble()
    write_csv(coord,path="coord_exo1_ggmap.csv")
    ```

    ```{r,teacher=correct}
    df <- read_csv("data/villes_fr.csv")
    df$Commune <- as.character(df$Commune)
    ```




    ::: {.corR data-latex=""}
    Attention, la ville de Lille n'est pas bien écrite ! Il faut la renommer :
    :::




    ```{r,teacher=correct}
    df$Commune[10]    
    df$Commune[10] <- "Lille"
    ```




    ::: {.corR data-latex=""}
    On calcule les coordonnées avec **mygeocode** et on représente les ville. Pour la taille des points, il suffit d'ajouter **size=`2014`** dans l'`aes` du `geom_point`.
    :::




    ```{r,echo=correct,eval=FALSE}
    coord <- mygeocode(as.character(df$Commune)) |> as_tibble()
    df1 <- bind_cols(df,coord)
    ggmap(fond)+geom_point(data=df1,aes(x=lon,y=lat),color="red")
    ggmap(fond)+geom_point(data=df1,aes(x=lon,y=lat,size=`2014`),color="red")
    ```

    ```{r,echo=FALSE,eval=correct}
    coord <- read_csv("data2/coord_exo1_ggmap.csv")
    df1 <- bind_cols(df,coord)
    ggmap(fond)+geom_point(data=df1,aes(x=lon,y=lat),color="red")
    ggmap(fond)+geom_point(data=df1,aes(x=lon,y=lat,size=`2014`),color="red")
    ```



:::

## Cartes avec contours, le format shapefile

`ggmap` permet de récupérer facilement des fonds de cartes et de placer des points dessus avec la syntaxe `ggplot`. Cependant, de nombreuses fonctions de ca package nécessitent une API et il est difficile de définir des contours (frontières de pays, départements ou régions) avec `ggmap`. Nous proposons ici de présenter brièvement le package **sf** qui va nous permettre de créer des cartes "avancées", en gérant les contours à l'aide d'objets particuliers mais aussi en prenant en compte différents systèmes de coordonnées. En effet, la terre n'est pas plate... mais une carte est souvent visualisée en 2D, il faut par conséquent réaliser des projections pour représenter des lieux définis par une coordonnée (comme la latitude et la longitude) sur une carte 2D. Ces projections sont généralement gérées par les packages qui permettent de faire de la cartographie comme **sf**. On pourra trouver de la documentation sur ce package aux url suivantes :

-   <https://statnmap.com/fr/2018-07-14-initiation-a-la-cartographie-avec-sf-et-compagnie/>
-   dans les **vignettes** sur la page du cran de ce package : <https://cran.r-project.org/web/packages/sf/index.html>

Ce package propose de définir un nouveau format **sf** adapté à la cartographie. Regardons par exemple l'objet **nc**




```{r}
library(sf)
nc <- st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
class(nc)
nc
```




Ces données contiennent des informations sur les morts subites de nourissons dans des villes de Caroline du Nord. On remarque que l'objet `nc` est au format `sf` et `data.frame`. On peut donc l'utiliser comme un `data.frame` classique. Le format `sf` permet l'ajout d'une colonne particulière (`geometry`) qui délimitera les villes à l'aide de polygones. Une fois l'objet obtenu au format **sf**, il est facile de visualiser la carte avec un **plot** classique




```{r}
plot(st_geometry(nc))
```




ou en utilisant le verbe `geom_sf` si on veut faire du `ggplot`




```{r}
ggplot(nc)+geom_sf()
```




Il devient dès lors facile de colorier des villes et d'ajouter leurs noms :




```{r}
ggplot(nc[1:3,]) +
   geom_sf(aes(fill = AREA)) + 
   geom_sf_label(aes(label = NAME))
```




La colonne `geometry` de `nc` est au format `MULTIPOLYGON`, elle permettra donc de délimiter les frontières des villes. Si maintenant on souhaite représenter une ville à l'aide d'un point défini par sa latitude et longitude, il va falloir modifier le format de cette colonne `geometry`. On peut le faire de la manière suivante :

1.  On récupère les latitudes et longitudes de chaque ville :




    ```{r,echo=FALSE,eval=FALSE}
    #Pour aller plus vite
    coord.ville.nc <- mygeocode(paste(as.character(nc$NAME),"NC")) |> as.data.frame()
    write_csv(coord.ville.nc,path="coord_ville_nc.csv")
    ```

    ```{r,echo=FALSE}
    coord.ville.nc <- read_csv("data2/coord_ville_nc.csv")
    #coord.ville.nc <- as.data.frame(coord.ville.nc)
    names(coord.ville.nc) <- c("lon","lat")
    ```

    ```{r,eval=FALSE,echo=TRUE}
    coord.ville.nc <- mygeocode(paste(as.character(nc$NAME),"NC"))
    coord.ville.nc <- as.data.frame(coord.ville.nc)
    names(coord.ville.nc) <- c("lon","lat")
    ```




2.  On met ces coordonnées au format `MULTIPOINT`




    ```{r,message=TRUE}
    coord.ville1.nc <- coord.ville.nc |>  
      filter(lon<=-77 & lon>=-85 & lat>=33 & lat<=37) |> 
      as.matrix() |> st_multipoint()  |> st_geometry() |> st_cast(to="POINT")
    coord.ville1.nc
    ```




3.  On indique que ces coordonnées sont des latitudes et longitude et on ajoute la colonne aux données initiales




    ```{r}
    st_crs(coord.ville1.nc) <- 4326 
    ```




4.  On peut enfin représenter la carte avec les frontières et les points :




    ```{r}
    ggplot(nc)+geom_sf()+geom_sf(data=coord.ville1.nc)
    ```




Le package `sf` possède également des fonctions très utiles pour traiter des données cartographiques, on peut citer par exemple :

-   `st_distance` qui permet de calculer des distances entre coordonnées ;
-   `st_centroid` pour calculer le centre d'une région ;
-   ...

On peut ainsi représenter les centres des villes délimitées par les polygones des données `nc` avec




```{r}
nc2 <- nc |> mutate(centre=st_centroid(nc)$geometry)
ggplot(nc2)+geom_sf()+geom_sf(aes(geometry=centre))
```




::: {#exr-exo-carto-sf1 name="Première carte avec sf"}
Nous nous servons de la carte GEOFLAR proposée par l'Institut Géographique National pour récupérer un fond de carte contenant les frontières des départements français. Cette carte est disponible sur le site [http: //professionnels.ign.fr/](http:%20//professionnels.ign.fr/) au format **shapefile**, elle se trouve dans l'archive **dpt.zip**. Il faut décompresser pour reproduire la carte. Grâce au package `sf`, cette carte, contenue dans la série de fichiers département du répertoire **dpt**, peut être importée dans un objet R :




```{r}
dpt <- read_sf("data/dpt")
ggplot(dpt) + geom_sf()
```




Refaire la carte de l'@exr-exo-carto-ggmap sur ce fond de carte.

::: {.corR data-latex=""}
On définit tout d'abord un `geometry` au format `MULTIPOINT`. On le transforme ensuite en un "vecteur" de longueur 30 au format `POINT` que l'on ajoute dans la dataframe qui contient les coordonnées des villes.
:::




```{r,teacher=correct,message=TRUE}
coord.ville1 <- data.frame(df1[,14:15]) |> 
  as.matrix() |> st_multipoint() |> st_geometry()
coord.ville2 <- st_cast(coord.ville1, to = "POINT")
coord.ville1
coord.ville2
```




::: {.corR data-latex=""}
On peut maintenant visualiser la carte demandée.
:::




```{r,teacher=correct}
st_geometry(df1) <- coord.ville2
st_crs(df1) <- 4326
df1
ggplot(dpt)+geom_sf(fill="white")+
  geom_sf(data=df1,aes(size=`2014`),color="red")+theme_void()
```



:::

::: {#exr-exo-carto-sf-tc name="Visualisation de taux de chômage avec sf"}
Nous souhaitons visualiser graphiquement les différences de taux de chômage par département entre deux années. Pour cela, nous disposons de chaque taux mesuré aux premiers trimestres des années 2006 et 2011 (variables `TCHOMB1T06`, `TCHOMB1T11`) qui se trouvent dans le jeu de données `tauxchomage.csv`.

1.  Importer le jeu de données.




    ```{r,teacher=correct}
    chomage <- read_delim("data/tauxchomage.csv",delim=";")
    ```




2.  Faire la jointure de cette table avec celle des frontières des départements. On pourra utiliser **inner_join**.




    ```{r,teacher=correct}
    dpt <- read_sf("data/dpt")
    dpt2 <- inner_join(dpt,chomage,by="CODE_DEPT")
    ```




3.  Comparer les taux de chômage en 2006 et 2011 (on le fera avec une carte pour les taux en 2006 et une autre pour les taux en 2011).




    ```{r,teacher=correct}
    dpt3 <- dpt2 |> select(A2006=TCHOMB1T06,A2011=TCHOMB1T11,geometry) |>
      as_tibble() |> 
      pivot_longer(-geometry,names_to="Annee",values_to="TxChomage") |>
      st_as_sf()
    ```

    ```{r,echo=FALSE,eval=FALSE}
    dpt3 <- dpt2 |> select(A2006=TCHOMB1T06,A2011=TCHOMB1T11,geometry) |>
      gather(key="Annee",value="TxChomage",-geometry)
    #  pivot_longer(-geometry,names_to="Annee",values_to="TxChomage")
    ```

    ```{r,teacher=correct}
    ggplot(dpt3) + aes(fill = TxChomage)+geom_sf() +
      facet_wrap(~Annee, nrow = 1)+
      scale_fill_gradient(low="white",high="brown")+theme_bw()
    ```



:::

### Challenge 1 : carte des températures avec sf {#sec-challenge1}

On souhaite ici faire une carte permettant de visualiser les température en France à un moment donné. Les données se trouvent sur le site des [données publiques de meteo france](https://donneespubliques.meteofrance.fr/?fond=produit&id_produit=90&id_rubrique=32). On peut notamment récupérer

-   les températures observées dans certaines stations en France les 15 derniers jours dans le lien téléchargement. On utilisera uniquement les identifiants de la station ainsi que la température observée (colonne `t`).
-   la géolocalisation de ces stations dans le lien [documentation](https://donneespubliques.meteofrance.fr/donnees_libres/Txt/Synop/postesSynop.csv)

1.  Importer les 2 bases nécessaires. On pourra les lire directement sur le site. Convertir les degrés Kelvin en degrés Celsius et faire la jointure de ces bases.




    ```{r,echo=FALSE,eval=FALSE}
    #Pour éviter les changements
    donnees <- read_delim("https://donneespubliques.meteofrance.fr/donnees_libres/Txt/Synop/synop.2020052415.csv",delim=";",col_types = cols(t=col_double()))
    station <- read_delim("https://donneespubliques.meteofrance.fr/donnees_libres/Txt/Synop/postesSynop.csv",delim=";")
    write_csv(donnees,path="donnees_temp_fr.csv")
    write_csv(station,path="station_temp_fr.csv")
    ```

    ```{r,echo=FALSE,eval=TRUE}
    donnees <- read_csv("data/donnees_temp_fr.csv")
    station <- read_csv("data/station_temp_fr.csv")
    donnees$t <- donnees$t-273.15 #on passe en degrés celcius
    temp <- donnees |> select(numer_sta,t)
    names(temp)[1] <- c("ID")
    D <- inner_join(temp, station, by = c("ID"))
    ```

    ```{r, echo=correct,eval=FALSE}
    donnees <- read_delim("https://donneespubliques.meteofrance.fr/donnees_libres/Txt/Synop/synop.2021122415.csv",delim=";",col_types = cols(t=col_double()))
    station <- read_delim("https://donneespubliques.meteofrance.fr/donnees_libres/Txt/Synop/postesSynop.csv",delim=";")
    donnees$t <- donnees$t-273.15 #on passe en degrés celcius
    temp <- donnees |> select(numer_sta,t)
    names(temp)[1] <- c("ID")
    D <- inner_join(temp, station, by = c("ID"))
    ```




2.  Éliminer les station d'outre mer (on pourra conserver uniquement les stations qui ont une longitude entre -20 et 25). On appellera ce tableau **station1**. Visualiser les stations sur la carte contenant les frontières des départements français.




    ```{r, teacher=correct}
    station1 <- D |> filter(Longitude<25 & Longitude>-20) |> na.omit()
    station4326 <- st_multipoint(as.matrix(station1[,5:4])) |> st_geometry()
    st_crs(station4326) <- 4326
    ggplot(dpt) + geom_sf()+geom_sf(data=station4326)
    ```




3.  Créer un dataframe au format **sf** qui contient les températures des stations ainsi que leurs coordonnées dans la colonne **geometry**. On pourra commencer avec




    ```{r,echo=TRUE,eval=correct}
    station2 <- station1 |> select(Longitude,Latitude) |> 
      as.matrix() |> st_multipoint() |> st_geometry()
    st_crs(station2) <- 4326
    station2 <- st_cast(station2, to = "POINT")
    ```

    ```{r,teacher=correct}
    df <- data.frame(temp=station1$t)
    st_geometry(df) <- station2
    ```




4.  Représenter les stations sur une carte de france. On pourra mettre un point de couleur différente en fonction de la température.




    ```{r,teacher=correct}
    ggplot(dpt) + geom_sf(fill="white")+
      geom_sf(data=df,aes(color=temp),size=2)+
      scale_color_continuous(low="yellow",high="red")
    ```




5.  On obtient les coordonnées des centroïdes des départements à l'aide de




    ```{r,echo=TRUE,eval=correct}
    centro <- st_centroid(dpt$geometry) 
    centro <- st_transform(centro,crs=4326)
    ```




    On déduit les distances entre ces centroïdes et les stations avec (**df** étant la table **sf** obtenue à la question 3).




    ```{r,echo=TRUE,eval=correct}
    DD <- st_distance(df,centro)
    ```




    Prédire la température de chaque département à l'aide de la règle du 1 plus proche voisin (la température du département $i$ sera celle de la station la plus proche du centroïde de $i$).




    ```{r,teacher=correct}
    NN <- apply(DD,2,order)[1,]
    t_prev <- station1[NN,2]
    ```




6.  Colorier les départements en fonction de la température prédite dans le département. On pourra faire varier le dégradé de couleur du jaune (pour les faibles températures) au rouge (pour les fortes).




    ```{r,teacher=correct}
    dpt1 <- dpt |> mutate(t_prev=as.matrix(t_prev))
    ggplot(dpt1) + geom_sf(aes(fill=t_prev)) +
      scale_fill_continuous(low="yellow",high="red")+theme_void()
    ```




    ::: {.corR data-latex=""}
    On peut supprimer les lignes de frontières avec
    :::




    ```{r,teacher=correct}
    ggplot(dpt1) + geom_sf(aes(fill=t_prev,color=t_prev)) + 
      scale_fill_continuous(low="yellow",high="red") + 
      scale_color_continuous(low="yellow",high="red")+theme_void()
    ```




### Trouver des cartes au format shapefile

Le plus souvent on ne va pas construire les fonds de carte au format shapefile "à la main" et il est bien entendu important de récupérer ces fonds de carte au préalable. La méthode la plus courante consiste à taper les bons mots clefs sur un moteur de recherche... On pourra par exemple utiliser :

-   des **packages R**, par exemple `rnaturalearth`:




    ```{r}
    world <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf")
    class(world)
    ggplot(data = world) +
    geom_sf(aes(fill = pop_est)) +
    scale_fill_viridis_c(option = "plasma", trans = "sqrt")+theme_void()
    ```




    On peut aussi visualiser la térre comme une sphère :




    ```{r}
    ggplot(data = world) +
    geom_sf() +
    coord_sf(crs = "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs ")
    ```




    Voir <https://www.r-spatial.org/r/2018/10/25/ggplot2-sf.html> pour plus de détails.

-   le **web**, par exemple le site [data gouv](https://www.data.gouv.fr/fr/datasets/contours-des-regions-francaises-sur-openstreetmap/#_):




    ```{r}
    regions <- read_sf("data/regions-20180101-shp/")
    ```




    Attention, la taille des objets peut être très (trop) grande\




    ```{r}
    format(object.size(regions),units="Mb")
    ```




    et la construction de la carte peut dans ce cas prendre beaucoup de temps... On peut réduire la taille avec ce type d'outils\




    ```{r}
    library(rmapshaper)
    regions1 <- ms_simplify(regions)
    format(object.size(regions1),units="Mb")
    ggplot(regions1)+geom_sf()+
      coord_sf(xlim = c(-5.5,10),ylim=c(41,51))+theme_void()
    ```




## Cartes interactives avec leaflet

`Leaflet` est un package permettant de faire de la *cartographie interactive*. On pourra consulter un descriptif synthétique [ici](https://rstudio.github.io/leaflet/). Le principe est similaire à ce qui a été présenté précédemment : les cartes sont construites à partir de couches qui se superposent. Un fond de carte s'obtient avec les fonctions `leaflet` et `addTiles`




```{r message=FALSE, warning=FALSE}
library(leaflet)
leaflet() |> addTiles()
```




On dispose de plusieurs styles de fonds de cartes (quelques exemples [ici](http://leaflet-extras.github.io/leaflet-providers/preview/)) :




```{r,echo=FALSE,eval=FALSE}
Paris <- c(2.351462,48.8567)
```

```{r}
Paris <- mygeocode("paris")
m2 <- leaflet() |> setView(lng = Paris[1], lat = Paris[2], zoom = 12) |> 
  addTiles()
m2 |> addProviderTiles("Stamen.Toner")
```

```{r}
m2 |> addProviderTiles("Wikimedia")
```

```{r}
m2 |> addProviderTiles("Esri.NatGeoWorldMap")
```

```{r}
m2 |>
  addProviderTiles("Stamen.Watercolor") |>
  addProviderTiles("Stamen.TonerHybrid")
```




Il est souvent utile de repérer des lieux sur une carte à l'aide de symboles. On pourra effectuer cela à l'aide des fonctions `addMarkers` et `addCircles`...




```{r}
data(quakes)
leaflet(data = quakes[1:20,]) |> addTiles() |>
  addMarkers(~long, ~lat, popup = ~as.character(mag))
```




On remarque que l'on utilise ici un **tilde** pour spécifier qu'on utilise des variables dans un `dataframe`.

Le caractère interactif de la carte permet d'ajouter de l'information lorsqu'on clique sur un marker (grâce à l'option `popup`). On peut également ajouter des **popups** qui contiennent plus d'information, voire des liens vers des sites web :




```{r}
content <- paste(sep = "<br/>",
  "<b><a href='http://www.samurainoodle.com'>Samurai Noodle</a></b>",
  "606 5th Ave. S",
  "Seattle, WA 98138"
)

leaflet() |> addTiles() |>
  addPopups(-122.327298, 47.597131, content,
    options = popupOptions(closeButton = FALSE)
  )
```




::: {#exr-exo-carto-popup-leaflet name="Popup avec leaflet"}
Placer un **popup** localisant l'Université Rennes 2 (Campus Villejean). On ajoutera un lien renvoyant sur le site de l'Université.




```{r, teacher=correct}
R2 <- mygeocode("Universite Rennes Villejean") |> as_tibble()
info <- paste(sep = "<br/>",
  "<b><a href='https://www.univ-rennes2.fr'>Universite Rennes 2</a></b>",
  "Campus Villejean")


leaflet() |> addTiles() |>  
  addPopups(R2[1]$lon, R2[2]$lat, info,options = popupOptions(closeButton = FALSE))

```



:::

### Challenge 2 : Visualisation des stations velib à Paris

Plusieurs villes dans le monde ont accepté de mettre en ligne les données sur l'occupation des stations velib. Ces données sont facilement accessibles et mises à jour en temps réel. On dispose généralement de la taille et la localisation des stations, la proportion de vélos disponibles... Il est possible de requêter (entre autres) :

-   sur les données [Decaux](https://developer.jcdecaux.com/#/opendata/vls?page=getstarted)
-   sur [Open data Paris](https://opendata.paris.fr/pages/home/)
-   sur [vlstats](http://vlsstats.ifsttar.fr/rawdata) pour des données mensuelles ou historiques ou encore sur Velib pour obtenir des fichiers qui sont rafraîchis régulièrement.

1.  Récupérer les données actuelles de velib disponibles pour la ville de Paris : <https://opendata.paris.fr/explore/dataset/velib-disponibilite-en-temps-reel/information/>. On pourra utiliser la fonction `read_delim` avec l'option `delim=";"`.




    ```{r,echo=FALSE,eval=FALSE}
    #Pour éviter les problèmes de changement
    sta.Paris <- read_delim("https://opendata.paris.fr/explore/dataset/velib-disponibilite-en-temps-reel/download/?format=csv&timezone=Europe/Berlin&use_labels_for_header=true",delim=";")
    write_csv(sta.Paris,path="sta.Paris.csv")
    ```

    ```{r,echo=FALSE,eval=TRUE}
    sta.Paris <- read_csv("data/sta.Paris.csv")
    ```

    ```{r, echo=correct,eval=FALSE}
    lien <- "https://opendata.paris.fr/explore/dataset/velib-disponibilite-en-temps-reel/download/?format=csv&timezone=Europe/Berlin&use_labels_for_header=true"
    sta.Paris <- read_delim(lien,delim=";")
    ```




2.  Décrire les variables du jeu de données.

    ::: {.corR data-latex=""}
    Nous avons de l'information sur la disponibilité, le remplissage... de stations velib parisiennes.
    :::

3.  Créer une variable `latitude` et une variable `longitude` à partir de la variable `Coordonnées géographiques`. On pourra utiliser la fonction **separate** du package `tidyr`.




    ```{r, echo=correct,eval=TRUE}
    sta.Paris1 <- sta.Paris |> separate(`Coordonnées géographiques`,
                                     into=c("lat","lon"),sep=",") |> 
      mutate(lat=as.numeric(lat),lon=as.numeric(lon))
    ```




4.  Visualiser les positions des stations sur une carte leaflet. On pourra utiliser l'option `clusterOptions = markerClusterOptions()` pour que la carte soit plus claire.




    ```{r, teacher=correct}
    map.velib1 <- leaflet(data = sta.Paris1) |> 
      addTiles() |>
      addCircleMarkers(~ lon, ~ lat,radius=3,
    stroke = FALSE, fillOpacity = 0.5,color="red"
      )

    map.velib1
    ```




    ::: {.corR data-latex=""}
    La carte est peu lisible, il y a en effet beaucoup de stations et il est difficile de bien les visualiser. Les choses deviennent plus claires en visualisant es groupes de station :
    :::




    ```{r, teacher=correct}
    leaflet(sta.Paris1) |> addTiles() |> 
      addMarkers(~ lon, ~ lat,clusterOptions = markerClusterOptions())
    ```




5.  Ajouter un popup qui permet de connaitre le nombre de vélos disponibles (électriques+mécanique) quand on clique sur la station (on pourra utiliser l'option **popup** dans la fonction **addCircleMarkers**).




    ```{r,teacher=correct}
    leaflet(data = sta.Paris1) |> 
      addTiles() |> 
      addMarkers(~ lon, ~ lat,clusterOptions = markerClusterOptions(),
                 popup = ~ sprintf("<b> Vélos dispos : %s</b>",
                                     as.character(`Nombre total vélos disponibles`)))

    #ou sans sprintf

    leaflet(data = sta.Paris1) |> 
      addTiles() |> 
      addMarkers(~ lon, ~ lat,clusterOptions = markerClusterOptions(),
                 popup = ~ paste("<b> Vélos dispos </b>:",
                                   as.character(`Nombre total vélos disponibles`)))
    ```




6.  Ajouter la nom de la station dans le popup.




    ```{r,teacher=correct}
    leaflet(data = sta.Paris1) |> 
      addTiles() |>
      addMarkers(~ lon, ~ lat,clusterOptions = markerClusterOptions(),
                 popup = ~ paste(as.character(`Nom station`),"<br/><b> Vélos dispos </b>:",
                                 as.character(`Nombre total vélos disponibles`)))
    ```




7.  Faire de même en utilisant des couleurs différentes en fonction de la proportion de vélos disponibles dans la station. On pourra utiliser les palettes de couleur




    ```{r}
    ColorPal1 <- colorNumeric(scales::seq_gradient_pal(low = "#132B43", high = "#56B1F7",
                                                   space = "Lab"), domain = c(0,1.2))
    ColorPal2 <- colorNumeric(scales::seq_gradient_pal(low = "red", high = "black", 
                                                   space = "Lab"), domain = c(0,1.2))
    ```

    ```{r, teacher=correct}
    leaflet(data = sta.Paris1) |> 
      addTiles() |>
      addCircleMarkers(~ lon, ~ lat,clusterOptions = markerClusterOptions(),
                       stroke = FALSE, fillOpacity = 0.7,
                       color=~ColorPal1(`Nombre total vélos disponibles`/
                                          `Capacité de la station`), 
                       popup = ~ paste(as.character(`Nom station`),"<br/><b> Vélos dispos </b>:",
                                       as.character(`Nombre total vélos disponibles`),
                                       sep=""))
    ```

    ```{r,teacher=correct}
    leaflet(data = sta.Paris1) |> 
      addTiles() |>
      addCircleMarkers(~ lon, ~ lat,clusterOptions = markerClusterOptions(),
                       stroke = FALSE, fillOpacity = 0.7,
                       color=~ColorPal2(`Nombre total vélos disponibles`/
                                          `Capacité de la station`),
                       radius=~(`Nombre total vélos disponibles`/
                              `Capacité de la station`)*40,
                       popup = ~ paste(as.character(`Nom station`),"<br/><b> Vélos dispos </b>:",
                                   as.character(`Nombre total vélos disponibles`),
                                   sep=""))

    ```




8.  Créer une fonction `local.station` qui permette de visualiser quelques stations autours d'une station choisie.




    ```{r,echo=correct,eval=TRUE}
    nom.station <- "Jussieu - Fossés Saint-Bernard"
    local.station <- function(nom.station){
      df <- sta.Paris1 |> filter(`Nom station`==nom.station)
      leaflet(data = sta.Paris1) |> setView(lng=df$lon,lat=df$lat,zoom=15) |>
    addTiles() |> 
    addCircleMarkers(~ lon, ~ lat,stroke = FALSE, fillOpacity = 0.7,
                    popup = ~ paste(as.character(`Nom station`),", Vélos dispos :",
                                    as.character(`Nombre total vélos disponibles`),
                                    sep="")) |>
    addMarkers(lng=df$lon,lat=df$lat,
               popup = ~ paste(nom.station,", Vélos dispos :",
                               as.character(df$`Nombre total vélos disponibles`),
                               sep=""),
               popupOptions = popupOptions(noHide = T))
    }
    ```




    La fonction devra par exemple renvoyer




    ```{r}
    local.station("Jussieu - Fossés Saint-Bernard")
    ```

    ```{r}
    local.station("Gare Montparnasse - Arrivée")
    ```




### Carte des températures avec leaflet

::: {#exr-leaflet-temp-challenge name="Challenge"}
Refaire la carte des températures du premier challenge (voir @sec-challenge1) en utilisant **leaflet**. On utilisera la table construite dans le challenge 1 et la fonction `addPolygons`. On pourra également ajouter un popup qui permet de visualiser le nom du département ainsi que la température prévue lorsqu'on clique dessus.




```{r,teacher=correct}
dpt2 <- st_transform(dpt1, crs = 4326)
dpt2$t_prev <- round(dpt2$t_prev)
pal <- colorNumeric(scales::seq_gradient_pal(low = "yellow", high = "red",
                                             space = "Lab"), domain = dpt2$t_prev)
m <- leaflet() |> addTiles() |> 
  addPolygons(data = dpt2,color=~pal(t_prev),fillOpacity = 0.6, 
              stroke = TRUE,weight=1,
              popup=~paste(as.character(NOM_DEPT),as.character(t_prev),sep=" : "),
              highlightOptions = highlightOptions(color = "black", weight = 3,bringToFront = TRUE)) |> 
  addLayersControl(options=layersControlOptions(collapsed = FALSE))
m
```




::: {.corR data-latex=""}
ou avec une autre palette de couleur
:::




```{r,teacher=correct}
pal1 <- colorNumeric(palette = c("inferno"),domain = dpt2$t_prev)
m1 <- leaflet() |> addTiles() |> 
  addPolygons(data = dpt2,color=~pal1(t_prev),fillOpacity = 0.6, 
              stroke = TRUE,weight=1,
              popup=~paste(as.character(NOM_DEPT),as.character(t_prev),sep=" : "),
              highlightOptions = highlightOptions(color = "black", weight = 3,bringToFront = TRUE)) |> 
  addLayersControl(options=layersControlOptions(collapsed = FALSE))
m1
```



:::

